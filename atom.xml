<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iflytek-duan.github.io/</id>
    <title>紫豪的Blog</title>
    <updated>2020-06-19T08:38:45.765Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://iflytek-duan.github.io/"/>
    <link rel="self" href="https://iflytek-duan.github.io/atom.xml"/>
    <subtitle>You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.</subtitle>
    <logo>https://iflytek-duan.github.io/images/avatar.png</logo>
    <icon>https://iflytek-duan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 紫豪的Blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】Gradle之多类型、类型包名后缀、源集（对应文件资源）配置]]></title>
        <id>https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/</id>
        <link href="https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/">
        </link>
        <updated>2020-06-10T01:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>一般情况下，我们的开发环境分为<code>debug</code>与<code>release</code>两个环境，这个一般在新建Android项目时，Gradle文件中已完成了默认的配置，代码如下（<code>debug</code>默认存在）：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
}
</code></pre>
<p>那么，如果我们在有的项目中需要配置其它环境（如alpha、beta等），这个时候就需要额外的配置了。</p>
<hr>
<h2 id="buildtypes配置构建类型">buildTypes（配置构建类型）</h2>
<p><code>buildTypes</code>位于<code>app-build.gradle</code>文件的<code>android{}</code>代码块中，它是用来创建和配置app的构建类型的，新建一个项目在模块的<code>build.gradle</code>文件中会默认生成<code>debug</code>与<code>release</code>两个环境版本。</p>
<hr>
<h2 id="多类型配置与其作用">多类型配置与其作用</h2>
<p>当我们app需要在不同的环境下生成对应的版本时，这个时候就需要在<code>buildTypes</code>内进行对应版本类型的配置工作（如：网络baseUrl的配置），示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-release.**/&quot;'
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }

    alpha {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-alpha.**/&quot;'
    }

    beta {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-beta.**/&quot;'
    }
}
</code></pre>
<p>通过如上配置，我们可以实现针对不同的环境创建对应的版本类型。</p>
<blockquote>
<p>通过Gradle-&gt;app-&gt;build-&gt;assemble可以一键进行所有类型版本的构建，生成对应的apk文件。</p>
</blockquote>
<hr>
<h2 id="applicationidsuffix">applicationIdSuffix</h2>
<p>该字段表示，在不改变当前程序默认ID（包名）的情况下，为其添加后缀。如：当前包名是<code>com.zihao.app</code>，如果你想区分测试包与线上包的情况，这个时候在<code>buildTypes-&gt;debug</code>中将<code>applicationIdSuffix</code>设置为<code>applicationIdSuffix &quot;.debug&quot;</code>，那么对应的包名就变成了<code>com.zihao.app.debug</code>，示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    ...
    debug {
        applicationIdSuffix &quot;.debug&quot;
    }
}
</code></pre>
<hr>
<h2 id="源集source-sets构建">源集（Source Sets）构建</h2>
<p>Android Studio会为每个模块将源代码和资源文件组成一个逻辑上的源集。每个模块的<code>main/</code>源集包括所有构建变种都是用的源码和资源。其它源集的目录是可选的，Android Studio不会自动为你创建他们，当你构建新的变种的时候。但是，构建具体的app版本的时候，创建于<code>main/</code>类似的源集，可以帮助组织Gradle应该使用的文件和资源（有助于让Gradle只应在构建特定应用版本时使用的文件和资源井然有序）。</p>
<blockquote>
<p>通常源代码是放在'src/main'文件目录下的，但是你可以根据不同的构建类型（比如debug、release、alpha等）区分不同的源文件，这样对应建立的文件夹就是一个不同的构建源。打个比方，<code>debug</code>的构建源为<code>src/debug</code>，<code>release</code>的构建源为<code>src/release</code>，而在<code>src/main</code>定义的为公共资源，最后在构建时进行合并操作。</p>
</blockquote>
<p><strong>构建源的命名规则如下</strong></p>
<ul>
<li><code>src/main/</code><br>
此源集包括所有构建变体共用的代码和资源。</li>
<li><code>src/&lt;buildTypes&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>buildType</code>使用的代码和资源。示例：<code>src/alpha</code>。</li>
<li><code>src/&lt;productFlavor&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>productFlavor</code>使用的代码和资源。示例：<code>src/baidu</code>。</li>
<li><code>src/&lt;productFlavorBuildType&gt;/</code><br>
创建此源集可加入特定构建变体专用的代码和资源。</li>
</ul>
<p>例如，要生成应用的“baiduDebug”版本，构建系统需要合并来自以下源集的代码、设置和资源：</p>
<ul>
<li><code>src/baiduDebug/</code>（构建变种源集）</li>
<li><code>src/debug/</code>（构建类型buildType源集）</li>
<li><code>src/baidu/</code>（productFlavor源集）</li>
<li><code>src/main/</code>（main源集）</li>
</ul>
<blockquote>
<p>注意：当你在Android Studio中创建一个新的文件或者目录时，使用File-&gt;New菜单项，你可以为一个具体的源集创建它。你可以选择的这些源集是基于你的构建配置的，并且Android Studio自动创建需要的目录，如果它们不存在的话。</p>
</blockquote>
<p><strong>源集的优先级</strong><br>
如果不同的源集包含同一个文件的不同版本，当决定哪个文件使用的时候Gradle使用下面的优先级顺序。（在左边的源集会重写右边的源集文件和设置）：</p>
<pre><code class="language-java">buildVariant &gt; buildType &gt; productFlavor &gt; main source set &gt; library dependencies
</code></pre>
<p>这可以让Gradle在构建的时候使用与具体构建变种相关的文件，当重用activity，应用逻辑，以及和其他版本通用的资源的时候。当<a href="https://developer.android.com/studio/build/manifest-merge.html">merging multiple manifests</a>的时候，Gradle使用同样的优先级顺序，因此每个构建变种可以定义不同的组件或者权限在最终的manifest文件中。<br>
学习更多关于创建自定义源集，点击<a href="https://developer.android.com/studio/build/build-variants.html">Create source sets for build variants</a>。</p>
<hr>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/89e5b0f3521e">【译】Android构建配置</a><br>
<a href="https://www.jianshu.com/p/e1efbade5d93">Android 多渠道打包配置</a><br>
<strong><a href="https://www.jianshu.com/p/a8870dccda1f">Android Studio Set of source 代码源集</a>  源集创建等操作</strong><br>
<strong><a href="https://developer.android.google.cn/studio/build/build-variants">官方文档</a></strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（二）数组Array]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/">
        </link>
        <updated>2020-04-20T03:10:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-kotlin-java中的数组对比">一、Kotlin、Java中的数组对比</h2>
<table>
    <tr>
        <th>数组分类</th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>IntArray</th>
        <th>int[]</th>
    </tr>
    <tr>
        <th>整型装箱</th>
        <th>Array&lt;Int&gt;</th>
        <th>Integer[]</th>
    </tr>
    <tr>
        <th>字符</th>
        <th>CharArray</th>
        <th>char[]</th>
    </tr>
    <tr>
        <th>字符装箱</th>
        <th>Array&lt;Char&gt;</th>
        <th>Character[]</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>Array<String></th>
        <th>String[]</th>
    </tr>
    <tr>
        <th>浮点型</th>
        <th>FloatArray</th>
        <th>float[]</th>
    </tr>
    <tr>
        <th>浮点型装箱</th>
        <th>Array&lt;Float&gt;</th>
        <th>Float[]</th>
    </tr>
    <tr>
        <th>双精度</th>
        <th>DoubleArray</th>
        <th>double[]</th>
    </tr>
    <tr>
        <th>双精度装箱</th>
        <th>Array&lt;Double&gt;</th>
        <th>Double[]</th>
    </tr>
</table>
<hr>
<h2 id="二-数组的创建">二、数组的创建</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] c = new int[]{1,2,3,4,5};
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val k0 = intArrayOf(1,2,3,4,5) // 变长参数
val k1 = IntArray(5){ it + 1 }// kotlin中新建一个对象不需要new关键字，参数一：数 组长度；参数二：lamda表达式，it的值为数组下标。

println(k0.contentToString())
println(k1.contentToString())
</code></pre>
</li>
</ul>
<hr>
<h2 id="三-数组的长度">三、数组的长度</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] array = new int[5];
System.out.println(array.length);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val array = IntArray(5)
println(array.size)
</code></pre>
</li>
</ul>
<hr>
<h2 id="四-数组的读写">四、数组的读写</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">String[] str = new String[]{&quot;Hello&quot;,&quot;World&quot;};
str[1] = &quot;Java&quot;;
System.out.println(str[0] + &quot;, &quot; + str[1]);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val str = arrayOf(&quot;Hello&quot;,&quot;World&quot;)
str[1] = &quot;Kotlin&quot;
println(&quot;${str[0]}, ${str[1]}&quot;)// 使用字符串模板打印
</code></pre>
</li>
</ul>
<hr>
<h2 id="五-数组的遍历">五、数组的遍历</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">float[] floats = new float[]{1,3,5,7};
for(float element : floats){
    System.out.println(element);
}

for(int i=0;i&lt;floats.length;i++){
    System.out.println(floats[i]);
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val floatArray = floatArrayOf(1f,3f,5f,7f)
for(element in floatArray){
    println(element)
}

// 或者使用以下方式遍历
floatArray.foreach{ element -&gt;
  println(element)
}

// 或者下面的方式（对标java中的 for(int i=0;i&lt;floats.length;i++)遍历方式）
for(i in floats.indices){
    println(floats[i])
}
</code></pre>
</li>
</ul>
<hr>
<h2 id="六-判断数组中是否包含某个元素数组的包含关系">六、判断数组中是否包含某个元素（数组的包含关系）</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">int[] intArray = new int[]{1,2,3,4,5};
for(int i : intArray){
    if(i == 4){
        System.out.println(&quot;4 exists in variable 'intArray'&quot;);
    }
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val intArray = IntArray(5){ it +1 }
if(4 in intArray){
    println(&quot;4 exists in variable 'intArray'&quot;)
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（一）基本类型]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2020-04-15T07:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>一、<code>Kotlin</code>、<code>Java</code>基本类型参照表</p>
<table>
    <tr>
        <th></th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>字节</th>
        <th>Byte</th>
        <th>byte/Byte</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>Int & Long</th>
        <th>int/integer & long/Long</th>
    </tr>
    <tr>
        <th>浮点型</th>
        <th>Float & Double</th>
        <th>float/Float & double/Double</th>
    </tr>
    <tr>
        <th>字符</th>
        <th>Char</th>
        <th>char/Char</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>String</th>
        <th>String</th>
    </tr>
</table>
<hr>
<p>二、声明变量</p>
<ul>
<li>
<p>只读变量（不可重新赋值）<br>
通过<code>val</code>修饰符声明，我们可以认为它是<strong>java中带了<code>final</code>修饰符的变量</strong>。</p>
<p>声明变量格式：修饰符 变量名: 类型 = 初始赋值<br>
示例：<br>
<code>val b: String = &quot;Hello Kotlin&quot;</code></p>
</li>
<li>
<p>可读写变量（可重新赋值）<br>
通过<code>var</code>修饰符声明。</p>
</li>
<li>
<p><code>Kotlin</code>支持自动类型推导<br>
<code>kotlin</code>支持自动类型的推导，可以到达简化代码的作用。<br>
如：<code>val b: String = &quot;Hello Kotlin&quot;</code>可以直接写成<code>val b = &quot;Hello Kotlin&quot;</code>。</p>
</li>
<li>
<p><code>Kotlin</code>与<code>Java</code>声明变量对比<br>
<code>Kotlin</code>声明变量：</p>
<pre><code class="language-kotlin">var a: Int = 2
val b: String = &quot;Hello Kotlin&quot;
</code></pre>
<p><code>Java</code>声明变量：</p>
<pre><code class="language-java">int a = 2;
final String b = &quot;Hello Java&quot;;
</code></pre>
</li>
</ul>
<hr>
<p>三、易混淆的Long类型标记<br>
在<code>Java</code>里，开发者在代码中通过以下方式进行<code>Long</code>类型的声明：</p>
<pre><code class="language-java">   long a = 12345678910l;// 小写易混淆
   long b = 12345678910L;// 大写方便识别
</code></pre>
<p>在<code>Kotlin</code>中，声明<code>Long</code>类型变量时，<strong>不支持小写L进行类型声明</strong>，否则编译器会报错</p>
<pre><code class="language-kotlin">   val c = 12345678910L
</code></pre>
<hr>
<p>四、<code>Kotlin</code>的数值类型转换<br>
在<code>Java</code>中，我们可以通过<strong>隐式转换</strong>的方式进行数值类型的转换，示例如下：</p>
<pre><code class="language-java">    int e = 10;
    long f = e;// implicit conversion
</code></pre>
<p>在<code>Kotlin</code>中，这种行为是不被允许的，这也是争议比较大的一点（支持者认为隐式转换安全性存在问题，反对者认为去除隐式转换给开发者带来一些开发过程中的麻烦），示例代码如下：</p>
<pre><code class="language-kotlin">    val e: Int = 10
    val f: Long = e.toLong()
</code></pre>
<hr>
<p>五、无符号类型（v1.3）<br>
<code>Kotlin</code>在兼容<code>C</code>时，创造了与之对应的无符号类型，具体如下：</p>
<table>
    <tr>
        <th></th>
        <th>有符号类型</th>
        <th>无符号类型</th>
    </tr>
    <tr>
        <th>字节</th>
        <th>Byte</th>
        <th>UByte</th>
    </tr>
    <tr>
        <th>短整型</th>
        <th>Short</th>
        <th>UShort</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>Int</th>
        <th>UInt</th>
    </tr>
    <tr>
        <th>长整型</th>
        <th>Long</th>
        <th>ULong</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>String</th>
        <th>String</th>
    </tr>
</table>
<p>无符号类型声明变量示例:</p>
<pre><code class="language-kotlin">    val ua: UInt = 10u
    val ub: ULong = 12345678910u
    val uc: UByte = 1u
</code></pre>
<hr>
<p>六、<code>Kotlin</code>中的变量值比较<br>
<code>kotlin</code>中的值比较通过<code>==</code>操作符来进行，这个有异于<code>Java</code>（<code>Java</code>中是通过<code>equals</code>方法进行值比较，<code>==</code>比较的是变量引用）。</p>
<p>示例：</p>
<pre><code class="language-kotlin">    val k = &quot;Hello Kotlin&quot;
    val m = String(&quot;Hello Kotlin&quot;.toCharArray())

    println(k === m) // compare references-比较引用
    println(k==m) // compare values-比较值
</code></pre>
<p>而<code>Java</code>中则是以下形式：</p>
<pre><code class="language-java">    String k = &quot;Hello Kotlin&quot;;
    String m = new String(&quot;Hello Kotlin&quot;);

    System.out.println(k==m);// compare references-比较引用
    System.out.println(k.equals(m));// compare values-比较值
</code></pre>
<hr>
<p>七、<code>Kotlin</code>中的字符串</p>
<ul>
<li>字符串比较
<ul>
<li>a == b ：比较内容，等价于<code>Java</code>的<code>equals</code>。</li>
<li>a === b ：比较对象是否是<strong>同一个对象</strong>。</li>
</ul>
</li>
<li>字符串模板
<ul>
<li>“Hello，$name”=&gt;&quot;Hello，小明&quot;</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】AndroidStudio升级3.6后如何进入xml布局文件代码编辑页面]]></title>
        <id>https://iflytek-duan.github.io/post/android-androidstudio-sheng-ji-36-hou-ru-he-jin-ru-xml-bu-ju-wen-jian-dai-ma-bian-ji-ye-mian/</id>
        <link href="https://iflytek-duan.github.io/post/android-androidstudio-sheng-ji-36-hou-ru-he-jin-ru-xml-bu-ju-wen-jian-dai-ma-bian-ji-ye-mian/">
        </link>
        <updated>2020-03-04T01:38:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="androidstudio升级36版本前的xml布局文件代码边界页面的进入方式">AndroidStudio升级3.6版本前的xml布局文件代码边界页面的进入方式</h2>
<figure data-type="image" tabindex="1"><img src="https://iflytek-duan.github.io//post-images/1583285974553.png" alt="3.6之前" loading="lazy"></figure>
<h2 id="升级36版本之后的xml预览界面左下角的designtext切换按钮找不到了">升级3.6版本之后的xml预览界面，左下角的Design/Text切换按钮找不到了</h2>
<figure data-type="image" tabindex="2"><img src="https://iflytek-duan.github.io//post-images/1583286117122.png" alt="3.6版本的预览界面" loading="lazy"></figure>
<h2 id="如何进入代码编辑界面点击右上角的图标切换进入即可详情如下图">如何进入代码编辑界面（点击右上角的图标切换进入即可），详情如下图</h2>
<figure data-type="image" tabindex="3"><img src="https://iflytek-duan.github.io//post-images/1583286340534.png" alt="解决方式" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】4G网络状态下访问ipv6反应慢的解决方案]]></title>
        <id>https://iflytek-duan.github.io/post/android-4g-wang-luo-zhuang-tai-xia-fang-wen-ipv6-fan-ying-man-de-jie-jue-fang-an/</id>
        <link href="https://iflytek-duan.github.io/post/android-4g-wang-luo-zhuang-tai-xia-fang-wen-ipv6-fan-ying-man-de-jie-jue-fang-an/">
        </link>
        <updated>2020-02-27T07:21:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>本文转自<strong>feshfans</strong>的博客 <a href="https://www.cnblogs.com/feshfans/p/10269629.html">Android 在 4G 下访问 IPV6 慢的解决方案</a>，仅用于记录解决方式，如有侵权，烦请告知。</p>
<hr>
<h1 id="起因">起因</h1>
<p>因公司iOS上架应用必须要使用ipv6协议，服务端这边新增了ipv6协议支持。<br>
Android刚开始在wifi网络环境下访问一切正常，后来在切换到4G网络状态下时，发下每次请求的时间相对之前都延长了好多，经过搜索参阅上文后，发现是每次解析都会收到两个ip地址（ipv6、ipv4），ipv6总是排在前面，会被优先使用ipv6地址访问解析，所以决定采用文中方案，使用自定义DNS方式将ipv4优先级放在第一位，杜绝此类问题的发生。</p>
<figure data-type="image" tabindex="1"><img src="https://iflytek-duan.github.io//post-images/1582788616554.png" alt="这里盗用一下排查图" loading="lazy"></figure>
<hr>
<h1 id="验证方式">验证方式</h1>
<p>使用下面的代码，验证DNS解析到的IP地址：</p>
<pre><code class="language-java">try {
    InetAddress[] inetAddresses = InetAddress.getAllByName(&quot;server.xxxx.cn&quot;);
    for (InetAddress inetAddress : inetAddresses) {
        Log.d(TAG, inetAddress.getHostAddress());
    }
} catch (UnknownHostException e) {
    e.printStackTrace();
}
</code></pre>
<hr>
<h1 id="解决方案">解决方案</h1>
<p>通过上面的验证，基本断定为 4G 网络下，Android 端通过 ipv6 连接的服务地址。客户端的Retrofit是基于okHttp3为核心实现的网络请求 ，在查看 javadoc 后，发现其提供了 DNS 接口，代码如下：</p>
<pre><code class="language-java">/**
 * A domain name service that resolves IP addresses for host names. Most applications will use the
 * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
 * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
 * addresses, or to force a specific known IP address.
 *
 * &lt;p&gt;Implementations of this interface must be safe for concurrent use.
 */
public interface Dns {
  /**
   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
   */
  Dns SYSTEM = hostname -&gt; {
    if (hostname == null) throw new UnknownHostException(&quot;hostname == null&quot;);
    try {
      return Arrays.asList(InetAddress.getAllByName(hostname));
    } catch (NullPointerException e) {
      UnknownHostException unknownHostException =
          new UnknownHostException(&quot;Broken system behaviour for dns lookup of &quot; + hostname);
      unknownHostException.initCause(e);
      throw unknownHostException;
    }
  };

  /**
   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
   * a connection to an address fails, OkHttp will retry the connection with the next address until
   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
   */
  List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException;
}
</code></pre>
<p>下面我们通过实现此接口，将解析到的 ip 顺序调整一下，如果是 ipv4 则将其放到数据的第一个，其它保持不变，如下图：</p>
<pre><code class="language-java">package com.dohenes.common.data.remote;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;

import okhttp3.Dns;
import retrofit2.internal.EverythingIsNonNull;

/**
 * ClassName Ipv4Dns
 * Describe TODO&lt;ipv4访问优先的DNS--解决ipv6环境下，4G网络访问太慢的问题&gt;
 * Author zihao
 * Date 2020/2/27 14:59
 * Version v1.0
 */
@EverythingIsNonNull
public class Ipv4PriorityDns implements Dns {

    @Override
    public List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException {
        try {
            // 获取指定主机-hostname的IP地址数组（Android解析指定域名获取到的IP）
            List&lt;InetAddress&gt; inetAddressList = new ArrayList&lt;&gt;();
            InetAddress[] inetAddresses = InetAddress.getAllByName(hostname);

            // 遍历获取到的地址，并将得到的ip顺序调整一下，使ipv4放在第一位（即优先使用ipv4协议访问）
            for (InetAddress inetAddress : inetAddresses) {
                if (inetAddress instanceof Inet4Address) {
                    inetAddressList.add(0, inetAddress);
                } else {
                    inetAddressList.add(inetAddress);
                }
            }

            return inetAddressList;
        } catch (NullPointerException exception) {
            UnknownHostException unknownHostException = new
                    UnknownHostException(&quot;Broken system behavior&quot;);
            unknownHostException.initCause(exception);
            throw unknownHostException;
        }
    }
}
</code></pre>
<p>然后设置Retrofit的OkHttpClient，修改其DNS解析类：</p>
<pre><code class="language-java">OkHttpClient.Builder okHttpClientBuilder = new OkHttpClient.Builder()
okHttpClientBuilder.dns(new MyDns());
OkHttpClient okHttpClient = okHttpClientBuilder.build();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】项目结构的演变之路——单Project、模块化、组件化、插件化]]></title>
        <id>https://iflytek-duan.github.io/post/android/</id>
        <link href="https://iflytek-duan.github.io/post/android/">
        </link>
        <updated>2020-02-25T02:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-前言">一、前言</h1>
<p>距2008年9月份Google发布Android 1.0操作系统至今已12个年头，Android操作系统、应用也在这个历程中逐步改进创新，丰富了用户的各方面体验。<br>
作为一个开发者，在工作过程中最直观的表现就是开发工具的演变（从Eclipse/IDEA更换为Android Studio）和项目结构的演变（单Project、模块化、组件化、插件化）。</p>
<hr>
<h1 id="二-开发工具的演变">二、开发工具的演变</h1>
<hr>
<h1 id="三-项目结构的演变">三、项目结构的演变</h1>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】32-硅谷人如何做Code Review]]></title>
        <id>https://iflytek-duan.github.io/post/zhu-yun-de-ji-zhu-guan-li-31/</id>
        <link href="https://iflytek-duan.github.io/post/zhu-yun-de-ji-zhu-guan-li-31/">
        </link>
        <updated>2019-12-23T09:14:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Code Review（代码评审）主要在软件开发的过程中，对源代码进行同级评审，其目的是找出并修正开发过程中出现的错误，保证软件质量，提高开发者自身水平。</p>
</blockquote>
<hr>
<h1 id="一-code-review的commint与pr">一、Code Review的Commint与PR</h1>
<p>硅谷大部分公司是使用Github企业版来管理自己的代码仓库，Github里的Commit和PR的概念在代码审核中风场重要。</p>
<ol>
<li>
<p><strong>Commit</strong><br>
Commit是指Github上的一次“Commit”行为，这是可以单独保存源代码的最小改动单位。</p>
</li>
<li>
<p><strong>PR</strong><br>
也就是Pull Request，是一次代码提交请求。一个PR可以包含一次Commit，也可以是多个。提交请求后Github会在相关页面上显示这次提交请求的代码和原代码的所有不同之处，这就是本次PR的所有改动。</p>
</li>
</ol>
<p>请求提交后，其它工程师可以在PR页面上提出意见和建议，也可以针对某一些代码的改动进行讨论，也可以给出整体评价。代码的作者也可以回复这些意见和建议，或者按照建议进行改动，新的改动将为本次PR中提交新的Commit（也可以覆盖之前的Commit）。</p>
<p>关于Github和Pull Request，池建强老师之前曾经写过一篇<a href="https://mp.weixin.qq.com/s/Ed_qK-Y8hh1hW_CCs6o7KA"><strong>GitHub 为编程世界带来了什么改变？</strong></a>，这边文章中有着比较详细的描述，大家有兴趣的话可以去阅读学习下。</p>
<hr>
<h1 id="二-关于代码合并规则">二、关于代码合并规则</h1>
<p>一般情况下，所有的PR都必须有至少一个人认可，才能进行合并。如果改动的内容涉及多个项目，则需要每个项目都有相关人员确认才可合并。还有一些特别关键的代码，比如支付相关的，通常也会需要支付组的人确认才行。</p>
<p>在代码合并之前，进行Code Review的工程师们会在Github的相关页上给出各种评论，页面是共享的，这些信息是大家都能看的到的。</p>
<p>有些评论是询问，代码的作者直接回复或解释就行，有些是指出代码的问题，代码作者可能会据此改动，也可能不会同意，那就需要回复评论，阐述观点，你来我往。有时候一个实现细节，讨论的主题可能多达十几条或几十条，最终需要达成一致才能合并。</p>
<hr>
<h1 id="三-帮助别人成长而不是帮他写代码">三、帮助别人成长，而不是帮他写代码</h1>
<p>可能有时候，有的人看到别人代码写的“太烂”，觉得在Github上回复评论效率太低，忍不住冲上去帮他搞定，其实这并不是一个非常合适的做法。</p>
<p>首先，从对方的角度来说，代码写不好，可能是对业务不熟悉，对编程语言不熟悉，也可能是公司整体代码结构的不熟悉。如果你帮他“写”，而不是耐心地指出哪里有问题，那么下一次他可能还不知道怎么做。这样不仅无益于别人成长，有时候会让别人有挫败感。</p>
<p>并且，帮别人写代码的方式可拓展性很差。即使Code Review会花掉十倍于你自己写代码的时间和精力，但它会让人明白代码该怎么写，从长远来看，这其实是在一定程度上“复制”了你的生产力赋能给被帮助的人。</p>
<p>作为一个工程师或者管理者，你不能什么都要自己写，尤其是作为一个带项目、新人的管理者，每天Code Review多个人的代码和写多个人的代码，长期而言哪个更划算呢？答案显然是前者更加划算、更具拓展性。</p>
<p>写代码是一个学习的过程，怎么做一个好的代码审核人更是一个学习和成长的过程。自己绕过一个坑不难，难的是看到别人那么走，远远的你就能告诉他那里有个坑，而他在你的指导下成长，以后也会帮助其它人支出类似的问题。</p>
<hr>
<h1 id="四-提交代码的类型">四、提交代码的类型</h1>
<p>在进行Code Review之前，要搞清楚提交的代码到底是干什么的，然后针对性的进行审核。我们一般把代码分为四类：</p>
<ol>
<li><strong>Bug修复</strong><br>
一般公司都有独立的Bug追踪和管理体系，每个Bug都有一个票据（标识）。代码提交的PR，一般是和票据有关的。</li>
<li><strong>代码优化</strong><br>
比如文件的移动和拆分、部分函数的重构、部分计算方式的修改等。</li>
<li><strong>系统迁移</strong><br>
包括代码库的拆分、用另外一种语言编程等。</li>
<li><strong>新系统和新功能</strong><br>
新功能在实现之前都要进行设计审核，最终版本的设计文档会包括数据库的Schema、API的签名（Signature）、代码的流程和模块等内容；相关代码的提交，也就是PR，一般是和设计文档挂钩的。</li>
</ol>
<p>了解了提交代码的作用，审核就会更有针对性和效率，也更容易从作者的角度阅读代码。</p>
<hr>
<h1 id="五-code-review的注意事项">五、Code Review的注意事项</h1>
<h2 id="从代码提交者的角度在代码审核中需要注意哪些问题呢">从代码提交者的角度，在代码审核中需要注意哪些问题呢？</h2>
<ol>
<li>
<p><strong>为什么要进行PR？</strong><br>
原因一定要在提交的时候写得非常清楚，才能帮助审核者理解这次改动是不是合理。上面说的四种提交代码的类型，具体是哪一种，应该写到PR的小结中，写的越详细越好。</p>
<p>这在以后需要进行回溯或追踪系统变化时，也是很有益的。如果改的是前端代码，最好贴一个改动前和改动后的截屏，让改动效果一目了然。</p>
</li>
<li>
<p><strong>除非是极其明显的单词拼写问题，尽量不要引入不是这个PR目的的改动。</strong><br>
PR要尽可能保持目标的单一性。每次遇到有人把一些代码结构的优化合并到功能相关的改动时，都会让人有一种肝火上升的感觉。</p>
<p>这种行为不仅会增加审核者的困难，降低效率，还会掩盖一些简单的错误。并且，如果因为功能的修改导致线上出了问题，一般需要退回到之前的版本，也就是反转PR，这时候，针对优化相关的改动也就必须被反转。总之是弊远远大于利的。</p>
</li>
<li>
<p><strong>找谁审核？</strong><br>
除了本组的人外，有时候代码还会和其他项目组的代码相关，需要找该组的成员审核，这时具体找谁呢？</p>
<p>一般有两个机制来解决这种问题。一是在Github中@一个组，比如Payment组，Risk组等，这些组会通知组里的所有人，相关人看到了就会回去审核；二是有一些组的代码，不希望其他组的人在自己不知道的情况下进行改动，就会设置规则，如果有人动了这些代码，也会通知到整个组。</p>
<p>最后，也是最重要的，一定确保所有的改动都是测试过的，无一例外。</p>
</li>
</ol>
<h2 id="从代码审核者的角度又需要注意哪些问题呢">从代码审核者的角度，又需要注意哪些问题呢？</h2>
<p>审核的粒度要多细？是不是每次审核都要花费很多时间？当然，如果时间足够，自然是看得越细越好。如果特别忙的时候，可以做一些筛选。</p>
<p>比如，你可以看一下算法或编程思路，然后加一个评论“算法部分看起来没有问题”；也可以只看你关心的部分，然后加评论“支付部分没问题”，或者“API部分没问题”。还可以再@一些你觉得可以对其他部分追加评论的人。</p>
<p>另外，如果新人的代码，尽可能的在风格、性能方面都加以审核。如果是一个老员工，这些方面可以给予更多的信任。</p>
<p>具体哪些方面需要审核呢？总结一下大概有以下几点：</p>
<ol>
<li>
<p><strong>代码格式</strong><br>
很多公司研发部都有相关编程风格指南（Code Style Guideline），这是大家约定俗成，避免公司代码风格不一致，也避免了一些“要不要把闭括号另起一行”的无谓争论。老员工除非不小心，通常大家不会弄错；新员工在这方面不太熟悉，就有可能出问题。这一类问题比较容易指出的。</p>
</li>
<li>
<p><strong>代码可读性</strong><br>
比如函数不要太长，太长就进行拆分。所有的变量要能说明它的用意和类型（比如hosting_address_hash，一看久知道是房东地址，而且是个哈希类型）。</p>
<p>不要有太多层的条件语句或者循环语句。不要有一个太长的布尔类型（Boolean）判断语句。如果一个函数别人需要看你的长篇注释才能明白，那这个函数就一定有重构的空间。另外，如果不可避免有一些注释，则一定要保证注释准确且与代码完全一致。</p>
</li>
<li>
<p><strong>业务边界和逻辑死角</strong><br>
你可以帮代码作者想想，他有没有遗漏掉任何业务边界和逻辑死角问题。很多时候这是业务逻辑相关的，尤其需要资深一点的工程师帮助其指出需要处理的所有情况。</p>
</li>
<li>
<p><strong>错误处理（Error Handling）</strong><br>
这是最常见的问题，也是代码审核最容易帮助别人织出来的问题。</p>
</li>
<li>
<p><strong>确保测试用例覆盖到了所有功能路径</strong><br>
严格来说，每段代码都应该有测试用例。如果开发者能够预见到其他人的代码改动会引发自己的代码问题，一定要增加额外的测试用例防止这种情况的发生。</p>
</li>
<li>
<p><strong>代码质量和规范</strong><br>
遵循公司制定的编程规范，比如，有重复的代码段，就应该提取出来公用，不要在代码里随意设置常数，所有的常数都应该有统一的定义，哪些变量应该是私有的，哪些应该是公有的，等等。</p>
</li>
<li>
<p><strong>代码架构</strong><br>
包括代码文件的组织方式，函数是不是抽象到lib或者helper文件里；是不是应该使用继承类；是不是和整个代码库的风格一致；API的定义是不是RESTful的等等。</p>
</li>
</ol>
<hr>
<h1 id="六-公司层面的支持">六、公司层面的支持</h1>
<p>从公司层面应该有哪些措施帮助员工有效的进行代码审核呢？</p>
<ol>
<li>统一的代码提交和审核流程与工具，并确保大家使用同样的工具，遵循相同的流程。</li>
<li>鼓励员工帮助别人审核代码，甚至可以做到绩效评估中。</li>
<li>制定统一的编程规范和代码风格，尤其是有争议的地方，这样可以解决因为一部分人的偏好带来的矛盾。</li>
</ol>
<p>代码审核和编程一样，都是日常工作，不要情绪化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava+Retrofit相关入门文章]]></title>
        <id>https://iflytek-duan.github.io/post/bu-fa-bu-rxjavaretrofit-xiang-guan-ru-men-wen-zhang/</id>
        <link href="https://iflytek-duan.github.io/post/bu-fa-bu-rxjavaretrofit-xiang-guan-ru-men-wen-zhang/">
        </link>
        <updated>2019-12-21T08:19:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="retrofit2">Retrofit2</h1>
<ul>
<li><a href="https://www.jianshu.com/p/0c055ad46b6c">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a></li>
<li><a href="https://www.jianshu.com/p/a3e162261ab6">Android Retrofit 2.0 的详细 使用攻略（含实例讲解）</a></li>
</ul>
<hr>
<h1 id="rxjava2">RxJava2</h1>
<ul>
<li><a href="https://blog.csdn.net/xiangshiweiyu_hd/article/details/83924707">初识RxJava（二）延时类 操作符</a></li>
<li><a href="https://www.jianshu.com/p/c935d0860186">RxJava2 实战知识梳理(1) - 后台执行耗时操作，实时通知 UI 更新</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】多状态布局管理器]]></title>
        <id>https://iflytek-duan.github.io/post/android-duo-zhuang-tai-bu-ju-guan-li-qi/</id>
        <link href="https://iflytek-duan.github.io/post/android-duo-zhuang-tai-bu-ju-guan-li-qi/">
        </link>
        <updated>2019-12-21T03:31:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="适用范围">适用范围</h1>
<p>主要适用于Acitivty/Fragment需要根据不同的状态来展示对应的状态页面。</p>
<hr>
<h1 id="设计思路">设计思路</h1>
<ul>
<li>设计一个布局管理器，用于管理各个状态的布局显示/隐藏</li>
<li>在布局管理器的根layout文件中，通过ViewStubCompat导入对应状态的layout</li>
<li>通过getViewGroup方法获取对应调用该管理类调用者的根Layout——即数据正常展示的UI</li>
<li>根据State进行对应的Page显示/隐藏</li>
</ul>
<hr>
<h1 id="实现后的statusviewcontrollerjava类">实现后的StatusViewController.java类</h1>
<pre><code class="language-java">package com.dohenes.common.view;

import android.annotation.SuppressLint;
import android.content.Context;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.ViewStubCompat;

import com.dohenes.common.R;

/**
 * ClassName StatusViewController
 * Describe TODO&lt;状态试图控制器&gt;
 * Author jgduan
 * Date 2019/12/16 11:09
 * Version v1.0
 */
public abstract class StatusViewController extends LinearLayout {
    private static final String TAG = StatusViewController.class.getSimpleName();

    /**
     * 状态枚举类，对应不同的状态
     * Empty对应空数据内容提示
     * Load对应加载中内容提示
     * Error对应发生异常提示
     * NoNetwork对应无网络提示
     * Success对应的是调用者自身的初始布局页面
     */
    public enum State {
        Empty, Load, Error, NoNetwork, Success
    }

    private View mEmptyView;// 空数据提示View
    private View mErrorView;// 异常提示View
    private View mLoadingView;// 加载中View
    private View mNoNetworkView;// 无网络提示View
    private ViewGroup mSuccessView;// 这个实际上是对标调用StatusViewController的Activity/Fragment根View
    private View mTitle;// Activity设置的Title

    public StatusViewController(@NonNull Context context) {
        super(context);
        init(context);
    }

    public StatusViewController(@NonNull Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    /**
     * 一些初始化的操作
     *
     * @param context context
     */
    private void init(@NonNull Context context) {
        setOrientation(VERTICAL);
        inflate(context, R.layout.status_view, this);// 引入多状态布局layout
        mSuccessView = getViewGroup();// 获取调用者自身的初始View
        mTitle = mSuccessView.findViewWithTag(&quot;title&quot;);
        this.addView(mSuccessView, ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT);// 添加默认的初始View进来
    }

    /**
     * 开始载入数据
     */
    private void loadData() {
        showPageWithState(State.Load);
        onLoadData();// 通知调用的Activity这里触发了载入数据操作，需要它配合做出处理
    }

    /**
     * 自定义的点击事件，只针对重新加载按钮
     */
    private OnClickListener mRetryClickListener = new OnClickListener() {

        @Override
        public void onClick(View v) {
            loadData();
        }
    };

    /**
     * 获取调用该控制器Activity/Fragment的根ViewGroup
     *
     * @return ViewGroup
     */
    public abstract ViewGroup getViewGroup();

    /**
     * 载入数据回调
     */
    public abstract void onLoadData();

    /**
     * 根据状态类型展示对应的页面
     *
     * @param status State
     */
    @SuppressLint(&quot;RestrictedApi&quot;)
    public void showPageWithState(State status) {
        if (mTitle != null) {
            String tag = (String) getChildAt(0).getTag();
            if (!TextUtils.equals(tag, &quot;title&quot;)) {// 没有标题栏
                mSuccessView.removeView(mTitle);
                addView(mTitle, 0);
            }
        }
        switch (status) {
            case Success:
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                mSuccessView.setVisibility(View.VISIBLE);
                break;
            case Empty:
                mSuccessView.setVisibility(View.GONE);
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mEmptyView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_empty);
                    mEmptyView = viewStub.inflate();
                } else {
                    mEmptyView.setVisibility(View.VISIBLE);
                }
                mEmptyView.findViewById(R.id.vcs_btn_empty)
                        .setOnClickListener(mRetryClickListener);
                break;
            case Load:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mLoadingView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_loading);
                    mLoadingView = viewStub.inflate();
                } else {
                    mLoadingView.setVisibility(View.VISIBLE);
                }
                break;
            case Error:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mErrorView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_error);
                    mErrorView = viewStub.inflate();
                } else {
                    mErrorView.setVisibility(View.VISIBLE);
                }
                mErrorView.findViewById(R.id.vcs_btn_error)
                        .setOnClickListener(mRetryClickListener);
                break;
            case NoNetwork:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mNoNetworkView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_no_network);
                    mNoNetworkView = viewStub.inflate();
                } else {
                    mNoNetworkView.setVisibility(View.VISIBLE);
                }
                mNoNetworkView.findViewById(R.id.vcs_btn_no_net)
                        .setOnClickListener(mRetryClickListener);
                break;
            default:
                break;
        }
    }

}

// 用法示例：修改baseActivity中的setContentView(getView());
//    private StatusViewController statusViewController;
//
//    private View getView() {
//        statusViewController = new StatusViewController(this) {
//            @Override
//            public ViewGroup getViewGroup() {
//                return getLayoutInflaterViewGroup();
//            }
//
//            @Override
//            public void onLoadData() {
//                // 这里需要在开始载入数据，暂时写个延迟模拟操作成功的效果
//                Observable.timer(3, TimeUnit.SECONDS, AndroidSchedulers.mainThread())
//                        .subscribe(new Observer&lt;Long&gt;() {
//                            @Override
//                            public void onCompleted() {
//                                statusViewController.showPageWithState(State.Success);
//                            }
//
//                            @Override
//                            public void onError(Throwable e) {
//
//                            }
//
//                            @Override
//                            public void onNext(Long aLong) {
//
//                            }
//                        });
//            }
//        };
//        // 默认应该是Load状态，示例放上Empty状态，便于更直观的体验流程
//        statusViewController.showPageWithState(StatusViewController.State.Empty);
//        return statusViewController;
//    }
//
//    private ViewGroup getLayoutInflaterViewGroup() {
//        return (ViewGroup) View.inflate(this, getContentViewID(), null);
//    }
</code></pre>
<hr>
<h1 id="对应的布局代码">对应的布局代码</h1>
<ul>
<li>StatusViewController对应的根布局<code>status_view.mxl</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_loading&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_loading&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_empty&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_empty&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_error&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_error&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_no_network&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_no_network&quot; /&gt;
&lt;/merge&gt;
</code></pre>
<ul>
<li><code>status_empty.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_empty&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vsc_empty_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_error.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_error&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vcs_error_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_loading.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@android:color/white&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;ProgressBar
        android:id=&quot;@+id/vcs_pb_loading&quot;
        style=&quot;?android:attr/progressBarStyle&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_no_network.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@android:color/white&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_no_net&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vcs_no_net_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li>对应的values值</li>
</ul>
<pre><code>    &lt;string name=&quot;vsc_empty_tips&quot;&gt;没有加载到数据，重新加载&lt;/string&gt;
    &lt;string name=&quot;vcs_error_tips&quot;&gt;发生错误，点击重新加载&lt;/string&gt;
    &lt;string name=&quot;vcs_no_net_tips&quot;&gt;没有网络，点击重试&lt;/string&gt;
</code></pre>
<hr>
<h1 id="三方库推荐">三方库推荐</h1>
<p><a href="https://github.com/hongyangAndroid/LoadingAndRetryManager"><strong>张鸿洋_LoadingAndRetryManager</strong></a><br>
<a href="https://github.com/long216/MultiPageControl"><strong>MultiPageControl</strong></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JJQ】Android开发规范（注释、命名、打包）]]></title>
        <id>https://iflytek-duan.github.io/post/jjq-android-ming-ming-gui-fan/</id>
        <link href="https://iflytek-duan.github.io/post/jjq-android-ming-ming-gui-fan/">
        </link>
        <updated>2019-12-19T08:11:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p><strong>统一、规范的命名有助于提升项目协作效率，也让代码的可读性、可维护性变得更加友好。</strong><br>
这里根据<a href="http://www.360sdn.com/2013/android_0517/144.html?ckvcbc=yz6j13"><strong>Google Android编程规范</strong></a>来对公司客户端研发输出一份相对全面、清晰的Android代码命名规范，如有异议，欢迎批评指正。</p>
<hr>
<h1 id="关于注释">关于注释</h1>
<p>在开发过程中，类、生僻对象命名、方法原则上都要加上相关注释，说明含义、用途。</p>
<hr>
<h1 id="各对象暂定的命名规范">各对象暂定的命名规范</h1>
<ul>
<li>
<p>项目名称(Project name)</p>
<ul>
<li>命名规则：<code>大驼峰式</code>命名，单词间连续无间隔；</li>
<li>示例：如新建一个名为BaiYaoWanJia的项目。</li>
</ul>
</li>
<li>
<p>模块命名(Module-Library name)</p>
<ul>
<li>命名规则：Library name采用<code>大驼峰式</code>命名，单词间连续无间隔，Module name会自动生成，不需修改；</li>
<li>示例：<img src="https://iflytek-duan.github.io//post-images/1576744158007.png" alt="Module.png" loading="lazy"></li>
</ul>
</li>
<li>
<p>包</p>
<ul>
<li>命名规则：小写、单词间连续无间隔，3级包名一般为<code>applicationId</code>或Module的根目录，4级包名对应不同的细分模块。</li>
<li>示例：
<ul>
<li>3级包名<code>applicationId</code>：一般为com.公司名.项目名，如com.dohenes.bywanjia 或 com.公司名.Module name，如com.dohenes.shop；</li>
<li>4级包名：com.公司名.项目名/Module name.xxx，具体可参考下图<img src="https://iflytek-duan.github.io//post-images/1576744848085.png" alt="4级包名示例1.png" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
<li>
<p>类</p>
<ul>
<li>命名规则：<code>大驼峰式</code>命名，可使用单词或者单词简写，在具体命名类时，会根据该类的类型不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>类目</th>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>普通java类</th>
          <th>java类</th>
          <th>大驼峰式命名法</th>
          <th>GetTime</th>
      </tr>
      <tr>
          <th rowspan="15">Android相关</th>
          <th>基类</th>
          <th>Base + 类别 / 功能</th>
          <th>BaseActivity / BaseFragment / BaseAdapter</th>
      </tr>
      <tr>
          <th>Activity</th>
          <th>模块名 + Activity</th>
          <th>LoginActivity</th>
      </tr>
      <tr>
          <th>Fragment</th>
          <th>模块名 + Fragment</th>
          <th>LoginFragment</th>
      </tr>
      <tr>
          <th>BroadcastReceiver</th>
          <th>功能名 + Receiver</th>
          <th>BootBroadcastReceiver</th>
      </tr>
      <tr>
          <th>Service</th>
          <th>模块名 / 功能名 + Service</th>
          <th>LoginService / BLEService</th>
      </tr>
      <tr>
          <th>自定义对话框Dialog</th>
          <th>功能名 + Dialog</th>
          <th>TipsDialog</th>
      </tr>
      <tr>
          <th>自定义View</th>
          <th>Custom + 功能名 + 组件名称(继承的组件名)</th>
          <th>CustomToast / CustomLayout</th>
      </tr>
      <tr>
          <th>自定义Widget</th>
          <th>功能名 + Widget</th>
          <th>LoginWidget</th>
      </tr>  
      <tr>
          <th>数据适配器类</th>
          <th>功能名 + Adapter</th>
          <th>WeatherAdapter</th>
      </tr>  
      <tr>
          <th>工具类</th>
          <th>功能名 + Util/Manager</th>
          <th>StringUtil / DatabaseManager</th>
      </tr>  
      <tr>
          <th>帮助类</th>
          <th>功能名 + Helper</th>
          <th>DBHelper</th>
      </tr>  
      <tr>
          <th>解析类</th>
          <th>功能名 + Parse</th>
          <th>GsonParse</th>
      </tr>   
      <tr>
          <th>异常类</th>
          <th>以Exception结尾</th>
          <th>LoginException</th>
      </tr>   
      <tr>
          <th>接口</th>
          <th>多以able或ible结尾，也可在类名前加I标明</th>
          <th>Runnable / Accessible / ILogin</th>
      </tr>   
      <tr>
          <th>回调</th>
          <th>功能名 + Callback</th>
          <th>LoginCallback</th>
      </tr>   
   </table>
</li>
<li>
<p>变量</p>
<ul>
<li>命名规则：小驼峰式命名，在具体命名变量时，会根据该变量的类型不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>变量</th>
          <th>m + 单词名</th>
          <th>private int mCount</th>
      </tr>
      <tr>
          <th>静态变量</th>
          <th>前缀添加s</th>
          <th>private static int sCount</th>
      </tr>
      <tr>
          <th>临时变量(代码块内的)</th>
          <th>小驼峰式命名</th>
          <th>int count</th>
      </tr>
      <tr>
          <th>常量</th>
          <th>CONSTANT_作用名</th>
          <th>CONSTANT_KEY_NAME</th>
      </tr>
      <tr>
          <th>Android UI控件</th>
          <th>m + 控件缩写 + 功能描述</th>
          <th>mTvTitle / mBtnLogin</th>
      </tr>
  </table>
</li>
<li>
<p>方法</p>
<ul>
<li>命名规则：小驼峰式命名,在具体命名方法名时，会根据该方法名的作用不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>功能</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>初始化</th>
          <th>init + 单词</th>
          <th>初始化布局：initView()</th>
      </tr>
      <tr>
          <th>判断 / 校验，返回至为boolean</th>
          <th>is + 单词 / check + 单词</th>
          <th>可见性：isVisible() / checkKey()</th>
      </tr>
      <tr>
          <th>显示/弹出提示框</th>
          <th>show + 单词</th>
          <th>显示提示信息：showTips()</th>
      </tr>
      <tr>
          <th>重置数据</th>
          <th>reset + 单词</th>
          <th>重置用户数据：resetUserData()</th>
      </tr>
      <tr>
          <th>保存数据</th>
          <th>save + 单词</th>
          <th>保存用户名：saveUserName()</th>
      </tr>
      <tr>
          <th>获取数据</th>
          <th>get + 单词</th>
          <th>获取用户名：getUserName()</th>
      </tr>
      <tr>
          <th>清除数据</th>
          <th>clear + 单词</th>
          <th>清除用户名:clearUserName()</th>
      </tr>
      <tr>
          <th>移除数据</th>
          <th>remove + 单词</th>
          <th>移除用户数据:removeUserData()</th>
      </tr>
      <tr>
          <th>绘制相关</th>
          <th>draw + 单词</th>
          <th>绘制线条:drawLine()</th>
      </tr>
  </table>
</li>
<li>
<p>参数</p>
<ul>
<li>命名规则：<code>小驼峰式</code>命名；</li>
<li>示例：如userName,phoneNumber等。</li>
</ul>
</li>
<li>
<p>资源</p>
<ul>
<li>布局资源(布局文件单词都要小写，中间用下划线<code>_</code>隔开)</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>activity布局</th>
          <th>activity_单词</th>
          <th>activity_main</th>
      </tr>
      <tr>
          <th>fragment布局</th>
          <th>fragment_单词</th>
          <th>fragment_main</th>
      </tr>
      <tr>
          <th>dialog布局</th>
          <th>dialog_单词</th>
          <th>dialog_tips</th>
      </tr>
      <tr>
          <th>popupwindow布局</th>
          <th>pw_单词</th>
          <th>pw_net_error</th>
      </tr>
      <tr>
          <th>列表子项布局</th>
          <th>item_单词</th>
          <th>item_message</th>
      </tr>
  </table>
<ul>
<li>控件ID</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>TextView</th>
          <th rowspan="11">模块名_控件缩写_功能单词名</th>
          <th>login_tv_title</th>
      </tr>
      <tr>
          <th>EditTextView</th>
          <th>login_et_userName</th>
      </tr>
      <tr>
          <th>ImageView</th>
          <th>login_iv_userHead</th>
      </tr>
      <tr>
          <th>Button</th>
          <th>login_btn</th>
      </tr>
      <tr>
          <th>CheckBox</th>
          <th>login_cb_status</th>
      </tr>
      <tr>
          <th>RadioButton</th>
          <th>login_rb_gender</th>
      </tr>
      <tr>
          <th>ListView</th>
          <th>main_lv_message</th>
      </tr>
      <tr>
          <th>GridView</th>
          <th>main_gv_cards</th>
      </tr>
      <tr>
          <th>LinearLayout</th>
          <th>login_lt_header</th>
      </tr>
      <tr>
          <th>RelativeLayout</th>
          <th>login_rl_header</th>
      </tr>
      <tr>
          <th>FragmentLayout / TableLayout / ConstraintLayout</th>
          <th>简写对应 fl / tl / cl</th>
      </tr>
  </table>
<ul>
<li>图片资源</li>
</ul>
  <table>
      <tr>
          <th>类目</th>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th rowspan = "10">Drawable / mipmap资源</th>
          <th>普通图标</th>
          <th>ic_具体模块_功能</th>
          <th>R.drawable.ic_user_login / R.drawable.ic_launcher</th>
      </tr>
      <tr>
          <th>背景资源</th>
          <th>bg_具体模块_功能</th>
          <th>R.drawable.bg_login</th>
      </tr>
      <tr>
          <th>样式选择器(selector)</th>
          <th>selector_具体模块_适用范围</th>
          <th>R.drawable.selector_login_btn</th>
      </tr>
      <tr>
          <th>样式形状(shape)</th>
          <th>shape_具体模块_适用范围</th>
          <th>R.drawable.shape_login_btn</th>
      </tr>
  </table>
<ul>
<li>动画资源</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>补间动画</th>
          <th>动画类型_方向</th>
          <th>淡入：fade_int；淡出：fade_out</th>
      </tr>
      <tr>
          <th>其余动画</th>
          <th>模块名_动画名</th>
          <th>login_jump</th>
      </tr>
  </table>
<ul>
<li>Values资源</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>color</th>
          <th>模块名_color</th>
          <th>login_color</th>
      </tr>
      <tr>
          <th>style</th>
          <th>模块名_style</th>
          <th>login_style</th>
      </tr>
      <tr>
          <th>theme</th>
          <th>模块名_theme</th>
          <th>login_theme</th>
      </tr>
      <tr>
          <th>string</th>
          <th>模块名_作用名</th>
          <th>user_name</th>
      </tr>
  </table>
<hr>
</li>
</ul>
<h1 id="关于app打包命名">关于App打包命名</h1>
<p>release版本在项目混淆、加固(目前采用360加固)的基础上，按照以下规范命名，其它情况不考虑：<br>
<a href="https://www.jianshu.com/p/d7dc4624a122">【Android】apk打包命名规则交流篇</a></p>
]]></content>
    </entry>
</feed>