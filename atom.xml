<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iflytek-duan.github.io/</id>
    <title>紫豪的Blog</title>
    <updated>2019-12-23T12:54:01.807Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://iflytek-duan.github.io/"/>
    <link rel="self" href="https://iflytek-duan.github.io//atom.xml"/>
    <subtitle>You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.</subtitle>
    <logo>https://iflytek-duan.github.io//images/avatar.png</logo>
    <icon>https://iflytek-duan.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 紫豪的Blog</rights>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】32-硅谷人如何做Code Review]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-31</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-31">
        </link>
        <updated>2019-12-23T09:14:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Code Review（代码评审）主要在软件开发的过程中，对源代码进行同级评审，其目的是找出并修正开发过程中出现的错误，保证软件质量，提高开发者自身水平。</p>
</blockquote>
<hr>
<h1 id="一-code-review的commint与pr">一、Code Review的Commint与PR</h1>
<p>硅谷大部分公司是使用Github企业版来管理自己的代码仓库，Github里的Commit和PR的概念在代码审核中风场重要。</p>
<ol>
<li>
<p><strong>Commit</strong><br>
Commit是指Github上的一次“Commit”行为，这是可以单独保存源代码的最小改动单位。</p>
</li>
<li>
<p><strong>PR</strong><br>
也就是Pull Request，是一次代码提交请求。一个PR可以包含一次Commit，也可以是多个。提交请求后Github会在相关页面上显示这次提交请求的代码和原代码的所有不同之处，这就是本次PR的所有改动。</p>
</li>
</ol>
<p>请求提交后，其它工程师可以在PR页面上提出意见和建议，也可以针对某一些代码的改动进行讨论，也可以给出整体评价。代码的作者也可以回复这些意见和建议，或者按照建议进行改动，新的改动将为本次PR中提交新的Commit（也可以覆盖之前的Commit）。</p>
<p>关于Github和Pull Request，池建强老师之前曾经写过一篇<a href="https://mp.weixin.qq.com/s/Ed_qK-Y8hh1hW_CCs6o7KA"><strong>GitHub 为编程世界带来了什么改变？</strong></a>，这边文章中有着比较详细的描述，大家有兴趣的话可以去阅读学习下。</p>
<hr>
<h1 id="二-关于代码合并规则">二、关于代码合并规则</h1>
<p>一般情况下，所有的PR都必须有至少一个人认可，才能进行合并。如果改动的内容涉及多个项目，则需要每个项目都有相关人员确认才可合并。还有一些特别关键的代码，比如支付相关的，通常也会需要支付组的人确认才行。</p>
<p>在代码合并之前，进行Code Review的工程师们会在Github的相关页上给出各种评论，页面是共享的，这些信息是大家都能看的到的。</p>
<p>有些评论是询问，代码的作者直接回复或解释就行，有些是指出代码的问题，代码作者可能会据此改动，也可能不会同意，那就需要回复评论，阐述观点，你来我往。有时候一个实现细节，讨论的主题可能多达十几条或几十条，最终需要达成一致才能合并。</p>
<hr>
<h1 id="三-帮助别人成长而不是帮他写代码">三、帮助别人成长，而不是帮他写代码</h1>
<p>可能有时候，有的人看到别人代码写的“太烂”，觉得在Github上回复评论效率太低，忍不住冲上去帮他搞定，其实这并不是一个非常合适的做法。</p>
<p>首先，从对方的角度来说，代码写不好，可能是对业务不熟悉，对编程语言不熟悉，也可能是公司整体代码结构的不熟悉。如果你帮他“写”，而不是耐心地指出哪里有问题，那么下一次他可能还不知道怎么做。这样不仅无益于别人成长，有时候会让别人有挫败感。</p>
<p>并且，帮别人写代码的方式可拓展性很差。即使Code Review会花掉十倍于你自己写代码的时间和精力，但它会让人明白代码该怎么写，从长远来看，这其实是在一定程度上“复制”了你的生产力赋能给被帮助的人。</p>
<p>作为一个工程师或者管理者，你不能什么都要自己写，尤其是作为一个带项目、新人的管理者，每天Code Review多个人的代码和写多个人的代码，长期而言哪个更划算呢？答案显然是前者更加划算、更具拓展性。</p>
<p>写代码是一个学习的过程，怎么做一个好的代码审核人更是一个学习和成长的过程。自己绕过一个坑不难，难的是看到别人那么走，远远的你就能告诉他那里有个坑，而他在你的指导下成长，以后也会帮助其它人支出类似的问题。</p>
<hr>
<h1 id="四-提交代码的类型">四、提交代码的类型</h1>
<p>在进行Code Review之前，要搞清楚提交的代码到底是干什么的，然后针对性的进行审核。我们一般把代码分为四类：</p>
<ol>
<li>Bug修复<br>
一般公司都有独立的Bug追踪和管理体系，每个Bug都有一个票据（标识）。代码提交的PR，一般是和票据有关的。</li>
<li>代码优化<br>
比如文件的移动和拆分、部分函数的重构、部分计算方式的修改等。</li>
<li>系统迁移<br>
包括代码库的拆分、用另外一种语言编程等。</li>
<li>新系统和新功能<br>
新功能在实现之前都要进行设计审核，最终版本的设计文档会包括数据库的Schema、API的签名（Signature）、代码的流程和模块等内容；相关代码的提交，也就是PR，一般是和设计文档挂钩的。</li>
</ol>
<p>了解了提交代码的作用，审核就会更有针对性和效率，也更容易从作者的角度阅读代码。</p>
<hr>
<h1 id="五-code-review的注意事项">五、Code Review的注意事项</h1>
<h2 id="从代码提交者的角度在代码审核中需要注意哪些问题呢">从代码提交者的角度，在代码审核中需要注意哪些问题呢？</h2>
<ol>
<li>
<p>为什么要进行PR？<br>
原因一定要在提交的时候写得非常清楚，才能帮助审核者理解这次改动是不是合理。上面说的四种提交代码的类型，具体是哪一种，应该写到PR的小结中，写的越详细越好。</p>
<p>这在以后需要进行回溯或追踪系统变化时，也是很有益的。如果改的是前端代码，最好贴一个改动前和改动后的截屏，让改动效果一目了然。</p>
</li>
<li>
<p>除非是极其明显的单词拼写问题，尽量不要引入不是这个PR目的的改动。<br>
PR要尽可能保持目标的单一性。每次遇到有人把一些代码结构的优化合并到功能相关的改动时，都会让人有一种肝火上升的感觉。</p>
<p>这种行为不仅会增加审核者的困难，降低效率，还会掩盖一些简单的错误。并且，如果因为功能的修改导致线上出了问题，一般需要退回到之前的版本，也就是反转PR，这时候，针对优化相关的改动也就必须被反转。总之是弊远远大于利的。</p>
</li>
<li>
<p>找谁审核？<br>
除了本组的人外，有时候代码还会和其他项目组的代码相关，需要找该组的成员审核，这时具体找谁呢？</p>
<p>一般有两个机制来解决这种问题。一是在Github中@一个组，比如Payment组，Risk组等，这些组会通知组里的所有人，相关人看到了就会回去审核；二是有一些组的代码，不希望其他组的人在自己不知道的情况下进行改动，就会设置规则，如果有人动了这些代码，也会通知到整个组。</p>
<p>最后，也是最重要的，一定确保所有的改动都是测试过的，无一例外。</p>
</li>
</ol>
<h2 id="从代码审核者的角度又需要注意哪些问题呢">从代码审核者的角度，又需要注意哪些问题呢？</h2>
<p>审核的粒度要多细？是不是每次审核都要花费很多时间？当然，如果时间足够，自然是看得越细越好。如果特别忙的时候，可以做一些筛选。</p>
<p>比如，你可以看一下算法或编程思路，然后加一个评论“算法部分看起来没有问题”；也可以只看你关心的部分，然后加评论“支付部分没问题”，或者“API部分没问题”。还可以再@一些你觉得可以对其他部分追加评论的人。</p>
<p>另外，如果新人的代码，尽可能的在风格、性能方面都加以审核。如果是一个老员工，这些方面可以给予更多的信任。</p>
<p>具体哪些方面需要审核呢？总结一下大概有以下几点：</p>
<ol>
<li>
<p>代码格式<br>
很多公司研发部都有相关编程风格指南（Code Style Guideline），这是大家约定俗成，避免公司代码风格不一致，也避免了一些“要不要把闭括号另起一行”的无谓争论。老员工除非不小心，通常大家不会弄错；新员工在这方面不太熟悉，就有可能出问题。这一类问题比较容易指出的。</p>
</li>
<li>
<p>代码可读性<br>
比如函数不要太长，太长就进行拆分。所有的变量要能说明它的用意和类型（比如hosting_address_hash，一看久知道是房东地址，而且是个哈希类型）。</p>
<p>不要有太多层的条件语句或者循环语句。不要有一个太长的布尔类型（Boolean）判断语句。如果一个函数别人需要看你的长篇注释才能明白，那这个函数就一定有重构的空间。另外，如果不可避免有一些注释，则一定要保证注释准确且与代码完全一致。</p>
</li>
<li>
<p>业务边界和逻辑死角<br>
你可以帮代码作者想想，他有没有遗漏掉任何业务边界和逻辑死角问题。很多时候这是业务逻辑相关的，尤其需要资深一点的工程师帮助其指出需要处理的所有情况。</p>
</li>
<li>
<p>错误处理（Error Handling）<br>
这是最常见的问题，也是代码审核最容易帮助别人织出来的问题。</p>
</li>
<li>
<p>确保测试用例覆盖到了所有功能路径<br>
严格来说，每段代码都应该有测试用例。如果开发者能够预见到其他人的代码改动会引发自己的代码问题，一定要增加额外的测试用例防止这种情况的发生。</p>
</li>
<li>
<p>代码质量和规范<br>
遵循公司制定的编程规范，比如，有重复的代码段，就应该提取出来公用，不要在代码里随意设置常数，所有的常数都应该有统一的定义，哪些变量应该是私有的，哪些应该是公有的，等等。</p>
</li>
<li>
<p>代码架构<br>
包括代码文件的组织方式，函数是不是抽象到lib或者helper文件里；是不是应该使用继承类；是不是和整个代码库的风格一致；API的定义是不是RESTful的等等。</p>
</li>
</ol>
<hr>
<h1 id="六公司层面的支持">六公司层面的支持</h1>
<p>从公司层面应该有哪些措施帮助员工有效的进行代码审核呢？</p>
<ol>
<li>统一的代码提交和审核流程与工具，并确保大家使用同样的工具，遵循相同的流程。</li>
<li>鼓励员工帮助别人审核代码，甚至可以做到绩效评估中。</li>
<li>制定统一的编程规范和代码风格，尤其是有争议的地方，这样可以解决因为一部分人的偏好带来的矛盾。</li>
</ol>
<p>代码审核和编程一样，都是日常工作，不要情绪化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava+Retrofit相关入门文章]]></title>
        <id>https://iflytek-duan.github.io//post/bu-fa-bu-rxjavaretrofit-xiang-guan-ru-men-wen-zhang</id>
        <link href="https://iflytek-duan.github.io//post/bu-fa-bu-rxjavaretrofit-xiang-guan-ru-men-wen-zhang">
        </link>
        <updated>2019-12-21T08:19:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="retrofit2">Retrofit2</h1>
<ul>
<li><a href="https://www.jianshu.com/p/0c055ad46b6c">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a></li>
<li><a href="https://www.jianshu.com/p/a3e162261ab6">Android Retrofit 2.0 的详细 使用攻略（含实例讲解）</a></li>
</ul>
<hr>
<h1 id="rxjava2">RxJava2</h1>
<ul>
<li><a href="https://blog.csdn.net/xiangshiweiyu_hd/article/details/83924707">初识RxJava（二）延时类 操作符</a></li>
<li><a href="https://www.jianshu.com/p/c935d0860186">RxJava2 实战知识梳理(1) - 后台执行耗时操作，实时通知 UI 更新</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】多状态布局管理器]]></title>
        <id>https://iflytek-duan.github.io//post/android-duo-zhuang-tai-bu-ju-guan-li-qi</id>
        <link href="https://iflytek-duan.github.io//post/android-duo-zhuang-tai-bu-ju-guan-li-qi">
        </link>
        <updated>2019-12-21T03:31:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="适用范围">适用范围</h1>
<p>主要适用于Acitivty/Fragment需要根据不同的状态来展示对应的状态页面。</p>
<hr>
<h1 id="设计思路">设计思路</h1>
<ul>
<li>设计一个布局管理器，用于管理各个状态的布局显示/隐藏</li>
<li>在布局管理器的根layout文件中，通过ViewStubCompat导入对应状态的layout</li>
<li>通过getViewGroup方法获取对应调用该管理类调用者的根Layout——即数据正常展示的UI</li>
<li>根据State进行对应的Page显示/隐藏</li>
</ul>
<hr>
<h1 id="实现后的statusviewcontrollerjava类">实现后的StatusViewController.java类</h1>
<pre><code class="language-java">package com.dohenes.common.view;

import android.annotation.SuppressLint;
import android.content.Context;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.ViewStubCompat;

import com.dohenes.common.R;

/**
 * ClassName StatusViewController
 * Describe TODO&lt;状态试图控制器&gt;
 * Author jgduan
 * Date 2019/12/16 11:09
 * Version v1.0
 */
public abstract class StatusViewController extends LinearLayout {
    private static final String TAG = StatusViewController.class.getSimpleName();

    /**
     * 状态枚举类，对应不同的状态
     * Empty对应空数据内容提示
     * Load对应加载中内容提示
     * Error对应发生异常提示
     * NoNetwork对应无网络提示
     * Success对应的是调用者自身的初始布局页面
     */
    public enum State {
        Empty, Load, Error, NoNetwork, Success
    }

    private View mEmptyView;// 空数据提示View
    private View mErrorView;// 异常提示View
    private View mLoadingView;// 加载中View
    private View mNoNetworkView;// 无网络提示View
    private ViewGroup mSuccessView;// 这个实际上是对标调用StatusViewController的Activity/Fragment根View
    private View mTitle;// Activity设置的Title

    public StatusViewController(@NonNull Context context) {
        super(context);
        init(context);
    }

    public StatusViewController(@NonNull Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    /**
     * 一些初始化的操作
     *
     * @param context context
     */
    private void init(@NonNull Context context) {
        setOrientation(VERTICAL);
        inflate(context, R.layout.status_view, this);// 引入多状态布局layout
        mSuccessView = getViewGroup();// 获取调用者自身的初始View
        mTitle = mSuccessView.findViewWithTag(&quot;title&quot;);
        this.addView(mSuccessView, ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT);// 添加默认的初始View进来
    }

    /**
     * 开始载入数据
     */
    private void loadData() {
        showPageWithState(State.Load);
        onLoadData();// 通知调用的Activity这里触发了载入数据操作，需要它配合做出处理
    }

    /**
     * 自定义的点击事件，只针对重新加载按钮
     */
    private OnClickListener mRetryClickListener = new OnClickListener() {

        @Override
        public void onClick(View v) {
            loadData();
        }
    };

    /**
     * 获取调用该控制器Activity/Fragment的根ViewGroup
     *
     * @return ViewGroup
     */
    public abstract ViewGroup getViewGroup();

    /**
     * 载入数据回调
     */
    public abstract void onLoadData();

    /**
     * 根据状态类型展示对应的页面
     *
     * @param status State
     */
    @SuppressLint(&quot;RestrictedApi&quot;)
    public void showPageWithState(State status) {
        if (mTitle != null) {
            String tag = (String) getChildAt(0).getTag();
            if (!TextUtils.equals(tag, &quot;title&quot;)) {// 没有标题栏
                mSuccessView.removeView(mTitle);
                addView(mTitle, 0);
            }
        }
        switch (status) {
            case Success:
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                mSuccessView.setVisibility(View.VISIBLE);
                break;
            case Empty:
                mSuccessView.setVisibility(View.GONE);
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mEmptyView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_empty);
                    mEmptyView = viewStub.inflate();
                } else {
                    mEmptyView.setVisibility(View.VISIBLE);
                }
                mEmptyView.findViewById(R.id.vcs_btn_empty)
                        .setOnClickListener(mRetryClickListener);
                break;
            case Load:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mLoadingView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_loading);
                    mLoadingView = viewStub.inflate();
                } else {
                    mLoadingView.setVisibility(View.VISIBLE);
                }
                break;
            case Error:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mNoNetworkView != null) {
                    mNoNetworkView.setVisibility(View.GONE);
                }
                if (mErrorView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_error);
                    mErrorView = viewStub.inflate();
                } else {
                    mErrorView.setVisibility(View.VISIBLE);
                }
                mErrorView.findViewById(R.id.vcs_btn_error)
                        .setOnClickListener(mRetryClickListener);
                break;
            case NoNetwork:
                mSuccessView.setVisibility(View.GONE);
                if (mEmptyView != null) {
                    mEmptyView.setVisibility(View.GONE);
                }
                if (mErrorView != null) {
                    mErrorView.setVisibility(View.GONE);
                }
                if (mLoadingView != null) {
                    mLoadingView.setVisibility(View.GONE);
                }
                if (mNoNetworkView == null) {
                    ViewStubCompat viewStub = findViewById(R.id.svc_stub_no_network);
                    mNoNetworkView = viewStub.inflate();
                } else {
                    mNoNetworkView.setVisibility(View.VISIBLE);
                }
                mNoNetworkView.findViewById(R.id.vcs_btn_no_net)
                        .setOnClickListener(mRetryClickListener);
                break;
            default:
                break;
        }
    }

}

// 用法示例：修改baseActivity中的setContentView(getView());
//    private StatusViewController statusViewController;
//
//    private View getView() {
//        statusViewController = new StatusViewController(this) {
//            @Override
//            public ViewGroup getViewGroup() {
//                return getLayoutInflaterViewGroup();
//            }
//
//            @Override
//            public void onLoadData() {
//                // 这里需要在开始载入数据，暂时写个延迟模拟操作成功的效果
//                Observable.timer(3, TimeUnit.SECONDS, AndroidSchedulers.mainThread())
//                        .subscribe(new Observer&lt;Long&gt;() {
//                            @Override
//                            public void onCompleted() {
//                                statusViewController.showPageWithState(State.Success);
//                            }
//
//                            @Override
//                            public void onError(Throwable e) {
//
//                            }
//
//                            @Override
//                            public void onNext(Long aLong) {
//
//                            }
//                        });
//            }
//        };
//        // 默认应该是Load状态，示例放上Empty状态，便于更直观的体验流程
//        statusViewController.showPageWithState(StatusViewController.State.Empty);
//        return statusViewController;
//    }
//
//    private ViewGroup getLayoutInflaterViewGroup() {
//        return (ViewGroup) View.inflate(this, getContentViewID(), null);
//    }
</code></pre>
<hr>
<h1 id="对应的布局代码">对应的布局代码</h1>
<ul>
<li>StatusViewController对应的根布局<code>status_view.mxl</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_loading&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_loading&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_empty&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_empty&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_error&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_error&quot; /&gt;

    &lt;androidx.appcompat.widget.ViewStubCompat
        android:id=&quot;@+id/svc_stub_no_network&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot;
        android:layout=&quot;@layout/status_no_network&quot; /&gt;
&lt;/merge&gt;
</code></pre>
<ul>
<li><code>status_empty.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_empty&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vsc_empty_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_error.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_error&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vcs_error_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_loading.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@android:color/white&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;ProgressBar
        android:id=&quot;@+id/vcs_pb_loading&quot;
        style=&quot;?android:attr/progressBarStyle&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li><code>status_no_network.xml</code></li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@android:color/white&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/vcs_btn_no_net&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;@string/vcs_no_net_tips&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<ul>
<li>对应的values值</li>
</ul>
<pre><code>    &lt;string name=&quot;vsc_empty_tips&quot;&gt;没有加载到数据，重新加载&lt;/string&gt;
    &lt;string name=&quot;vcs_error_tips&quot;&gt;发生错误，点击重新加载&lt;/string&gt;
    &lt;string name=&quot;vcs_no_net_tips&quot;&gt;没有网络，点击重试&lt;/string&gt;
</code></pre>
<hr>
<h1 id="三方库推荐">三方库推荐</h1>
<p><a href="https://github.com/hongyangAndroid/LoadingAndRetryManager"><strong>张鸿洋_LoadingAndRetryManager</strong></a><br>
<a href="https://github.com/long216/MultiPageControl"><strong>MultiPageControl</strong></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JJQ】Android开发规范（注释、命名、打包）]]></title>
        <id>https://iflytek-duan.github.io//post/jjq-android-ming-ming-gui-fan</id>
        <link href="https://iflytek-duan.github.io//post/jjq-android-ming-ming-gui-fan">
        </link>
        <updated>2019-12-19T08:11:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p><strong>统一、规范的命名有助于提升项目协作效率，也让代码的可读性、可维护性变得更加友好。</strong><br>
这里根据<a href="http://www.360sdn.com/2013/android_0517/144.html?ckvcbc=yz6j13"><strong>Google Android编程规范</strong></a>来对公司客户端研发输出一份相对全面、清晰的Android代码命名规范，如有异议，欢迎批评指正。</p>
<hr>
<h1 id="关于注释">关于注释</h1>
<p>在开发过程中，类、生僻对象命名、方法原则上都要加上相关注释，说明含义、用途。</p>
<hr>
<h1 id="各对象暂定的命名规范">各对象暂定的命名规范</h1>
<ul>
<li>
<p>项目名称(Project name)</p>
<ul>
<li>命名规则：<code>大驼峰式</code>命名，单词间连续无间隔；</li>
<li>示例：如新建一个名为BaiYaoWanJia的项目。</li>
</ul>
</li>
<li>
<p>模块命名(Module-Library name)</p>
<ul>
<li>命名规则：Library name采用<code>大驼峰式</code>命名，单词间连续无间隔，Module name会自动生成，不需修改；</li>
<li>示例：<img src="https://iflytek-duan.github.io//post-images/1576744158007.png" alt="Module.png"></li>
</ul>
</li>
<li>
<p>包</p>
<ul>
<li>命名规则：小写、单词间连续无间隔，3级包名一般为<code>applicationId</code>或Module的根目录，4级包名对应不同的细分模块。</li>
<li>示例：
<ul>
<li>3级包名<code>applicationId</code>：一般为com.公司名.项目名，如com.dohenes.bywanjia 或 com.公司名.Module name，如com.dohenes.shop；</li>
<li>4级包名：com.公司名.项目名/Module name.xxx，具体可参考下图<img src="https://iflytek-duan.github.io//post-images/1576744848085.png" alt="4级包名示例1.png"></li>
</ul>
</li>
</ul>
</li>
<li>
<p>类</p>
<ul>
<li>命名规则：<code>大驼峰式</code>命名，可使用单词或者单词简写，在具体命名类时，会根据该类的类型不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>类目</th>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>普通java类</th>
          <th>java类</th>
          <th>大驼峰式命名法</th>
          <th>GetTime</th>
      </tr>
      <tr>
          <th rowspan="15">Android相关</th>
          <th>基类</th>
          <th>Base + 类别 / 功能</th>
          <th>BaseActivity / BaseFragment / BaseAdapter</th>
      </tr>
      <tr>
          <th>Activity</th>
          <th>模块名 + Activity</th>
          <th>LoginActivity</th>
      </tr>
      <tr>
          <th>Fragment</th>
          <th>模块名 + Fragment</th>
          <th>LoginFragment</th>
      </tr>
      <tr>
          <th>BroadcastReceiver</th>
          <th>功能名 + Receiver</th>
          <th>BootBroadcastReceiver</th>
      </tr>
      <tr>
          <th>Service</th>
          <th>模块名 / 功能名 + Service</th>
          <th>LoginService / BLEService</th>
      </tr>
      <tr>
          <th>自定义对话框Dialog</th>
          <th>功能名 + Dialog</th>
          <th>TipsDialog</th>
      </tr>
      <tr>
          <th>自定义View</th>
          <th>Custom + 功能名 + 组件名称(继承的组件名)</th>
          <th>CustomToast / CustomLayout</th>
      </tr>
      <tr>
          <th>自定义Widget</th>
          <th>功能名 + Widget</th>
          <th>LoginWidget</th>
      </tr>  
      <tr>
          <th>数据适配器类</th>
          <th>功能名 + Adapter</th>
          <th>WeatherAdapter</th>
      </tr>  
      <tr>
          <th>工具类</th>
          <th>功能名 + Util/Manager</th>
          <th>StringUtil / DatabaseManager</th>
      </tr>  
      <tr>
          <th>帮助类</th>
          <th>功能名 + Helper</th>
          <th>DBHelper</th>
      </tr>  
      <tr>
          <th>解析类</th>
          <th>功能名 + Parse</th>
          <th>GsonParse</th>
      </tr>   
      <tr>
          <th>异常类</th>
          <th>以Exception结尾</th>
          <th>LoginException</th>
      </tr>   
      <tr>
          <th>接口</th>
          <th>多以able或ible结尾，也可在类名前加I标明</th>
          <th>Runnable / Accessible / ILogin</th>
      </tr>   
      <tr>
          <th>回调</th>
          <th>功能名 + Callback</th>
          <th>LoginCallback</th>
      </tr>   
   </table>
</li>
<li>
<p>变量</p>
<ul>
<li>命名规则：小驼峰式命名，在具体命名变量时，会根据该变量的类型不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>变量</th>
          <th>m + 单词名</th>
          <th>private int mCount</th>
      </tr>
      <tr>
          <th>静态变量</th>
          <th>前缀添加s</th>
          <th>private static int sCount</th>
      </tr>
      <tr>
          <th>临时变量(代码块内的)</th>
          <th>小驼峰式命名</th>
          <th>int count</th>
      </tr>
      <tr>
          <th>常量</th>
          <th>CONSTANT_作用名</th>
          <th>CONSTANT_KEY_NAME</th>
      </tr>
      <tr>
          <th>Android UI控件</th>
          <th>m + 控件缩写 + 功能描述</th>
          <th>mTvTitle / mBtnLogin</th>
      </tr>
  </table>
</li>
<li>
<p>方法</p>
<ul>
<li>命名规则：小驼峰式命名,在具体命名方法名时，会根据该方法名的作用不同而附加额外的命名规则；</li>
<li>示例：</li>
</ul>
<table>
      <tr>
          <th>功能</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>初始化</th>
          <th>init + 单词</th>
          <th>初始化布局：initView()</th>
      </tr>
      <tr>
          <th>判断 / 校验，返回至为boolean</th>
          <th>is + 单词 / check + 单词</th>
          <th>可见性：isVisible() / checkKey()</th>
      </tr>
      <tr>
          <th>显示/弹出提示框</th>
          <th>show + 单词</th>
          <th>显示提示信息：showTips()</th>
      </tr>
      <tr>
          <th>重置数据</th>
          <th>reset + 单词</th>
          <th>重置用户数据：resetUserData()</th>
      </tr>
      <tr>
          <th>保存数据</th>
          <th>save + 单词</th>
          <th>保存用户名：saveUserName()</th>
      </tr>
      <tr>
          <th>获取数据</th>
          <th>get + 单词</th>
          <th>获取用户名：getUserName()</th>
      </tr>
      <tr>
          <th>清除数据</th>
          <th>clear + 单词</th>
          <th>清除用户名:clearUserName()</th>
      </tr>
      <tr>
          <th>移除数据</th>
          <th>remove + 单词</th>
          <th>移除用户数据:removeUserData()</th>
      </tr>
      <tr>
          <th>绘制相关</th>
          <th>draw + 单词</th>
          <th>绘制线条:drawLine()</th>
      </tr>
  </table>
</li>
<li>
<p>参数</p>
<ul>
<li>命名规则：<code>小驼峰式</code>命名；</li>
<li>示例：如userName,phoneNumber等。</li>
</ul>
</li>
<li>
<p>资源</p>
<ul>
<li>布局资源(布局文件单词都要小写，中间用下划线<code>_</code>隔开)</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>activity布局</th>
          <th>activity_单词</th>
          <th>activity_main</th>
      </tr>
      <tr>
          <th>fragment布局</th>
          <th>fragment_单词</th>
          <th>fragment_main</th>
      </tr>
      <tr>
          <th>dialog布局</th>
          <th>dialog_单词</th>
          <th>dialog_tips</th>
      </tr>
      <tr>
          <th>popupwindow布局</th>
          <th>pw_单词</th>
          <th>pw_net_error</th>
      </tr>
      <tr>
          <th>列表子项布局</th>
          <th>item_单词</th>
          <th>item_message</th>
      </tr>
  </table>
<ul>
<li>控件ID</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>TextView</th>
          <th rowspan="11">模块名_控件缩写_功能单词名</th>
          <th>login_tv_title</th>
      </tr>
      <tr>
          <th>EditTextView</th>
          <th>login_et_userName</th>
      </tr>
      <tr>
          <th>ImageView</th>
          <th>login_iv_userHead</th>
      </tr>
      <tr>
          <th>Button</th>
          <th>login_btn</th>
      </tr>
      <tr>
          <th>CheckBox</th>
          <th>login_cb_status</th>
      </tr>
      <tr>
          <th>RadioButton</th>
          <th>login_rb_gender</th>
      </tr>
      <tr>
          <th>ListView</th>
          <th>main_lv_message</th>
      </tr>
      <tr>
          <th>GridView</th>
          <th>main_gv_cards</th>
      </tr>
      <tr>
          <th>LinearLayout</th>
          <th>login_lt_header</th>
      </tr>
      <tr>
          <th>RelativeLayout</th>
          <th>login_rl_header</th>
      </tr>
      <tr>
          <th>FragmentLayout / TableLayout / ConstraintLayout</th>
          <th>简写对应 fl / tl / cl</th>
      </tr>
  </table>
<ul>
<li>图片资源</li>
</ul>
  <table>
      <tr>
          <th>类目</th>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th rowspan = "10">Drawable / mipmap资源</th>
          <th>普通图标</th>
          <th>ic_具体模块_功能</th>
          <th>R.drawable.ic_user_login / R.drawable.ic_launcher</th>
      </tr>
      <tr>
          <th>样式选择器(selector)</th>
          <th>selector_具体模块_适用范围</th>
          <th>R.drawable.selector_login_btn</th>
      </tr>
      <tr>
          <th>样式形状(shape)</th>
          <th>shape_具体模块_适用范围</th>
          <th>R.drawable.shape_login_btn</th>
      </tr>
  </table>
<ul>
<li>动画资源</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>补间动画</th>
          <th>动画类型_方向</th>
          <th>淡入：fade_int；淡出：fade_out</th>
      </tr>
      <tr>
          <th>其余动画</th>
          <th>模块名_动画名</th>
          <th>login_jump</th>
      </tr>
  </table>
<ul>
<li>Values资源</li>
</ul>
  <table>
      <tr>
          <th>类型</th>
          <th>命名规则描述</th>
          <th>命名示例</th>
      </tr>
      <tr>
          <th>color</th>
          <th>模块名_color</th>
          <th>login_color</th>
      </tr>
      <tr>
          <th>style</th>
          <th>模块名_style</th>
          <th>login_style</th>
      </tr>
      <tr>
          <th>theme</th>
          <th>模块名_theme</th>
          <th>login_theme</th>
      </tr>
      <tr>
          <th>string</th>
          <th>模块名_作用名</th>
          <th>user_name</th>
      </tr>
  </table>
<hr>
</li>
</ul>
<h1 id="关于app打包命名">关于App打包命名</h1>
<p>release版本在项目混淆、加固(目前采用360加固)的基础上，按照以下规范命名，其它情况不考虑：<br>
<a href="https://www.jianshu.com/p/d7dc4624a122">【Android】apk打包命名规则交流篇</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】29-硅谷互联网公司的开发流程]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-29-huo-gu-hu-lian-wang-gong-si-de-kai-fa-liu-cheng</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-29-huo-gu-hu-lian-wang-gong-si-de-kai-fa-liu-cheng">
        </link>
        <updated>2019-12-09T02:43:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言硅谷互联网公司的开发流程">前言：硅谷互联网公司的开发流程</h1>
<p>总的来说，硅谷互联网公司的开发流程包括以下几个阶段：</p>
<ol>
<li>OKR的设立；</li>
<li>主项目及其子项目的确立；</li>
<li>每个子项目的生命周期；</li>
<li>主项目的生命周期；</li>
<li>收尾、维护、复盘。</li>
</ol>
<hr>
<h1 id="第一点okr的设立">第一点，OKR的设立</h1>
<p>所有项目的起始，都应从Roadmap做起。硅谷公司的OKR（Objectives and Key Results）一般都是自顶而下的。也就是说，先有整个公司的OKR，然后有每个部门的OKR，继而是大组的OKR，再到小组的OKR，确保整个公司有一致的目标。在这个过程里面，技术驱动反映在哪些方面呢：</p>
<p>首先，确定Roadmap的过程中，我们会采用调查（Survey）模式，确保工程师的声音可以准确地触达管理层。比如:工程师们觉得基础架构比较薄弱，公司就会加大这一块的支持力度。如果大家觉得开发环境很低效，就会把这个因素也放到OKR考虑。硅谷的公司一般会分为产品组和系统架构组。总的来说，系统架构组的OKR里，工程师的声音会很大。</p>
<p>其次，项目怎么做，怎么规划，一般是由工程师来决定的。OKR只确立目标，是不是要构建新的服务，是不是要沿用现有架构，如何进行技术选型等，这些不是OKR的组成部分。</p>
<p>最后，估算OKR里的工期目标的时候，我们会去除一些用来做技术创新和支持的时间，比如编程马拉松，开源支持等事务。谷歌的员工会给自己预留20%的自由项目时间，这些都是时间缓冲区。</p>
<blockquote>
<p>OKR是企业进行目标管理的一个简单有效的系统，能够将目标管理自上而下的贯穿到基层。</p>
</blockquote>
<hr>
<h1 id="第二点主项目及其子项目的确立">第二点，主项目及其子项目的确立</h1>
<p>一旦确立了OKR，下一步就是确立主项目和子项目了。主项目是主要的技术或商业产品，一般由产品经理、技术经理和一些技术骨干经过产品需求和技术讨论后，确定要做什么（Scope），不做什么（Non Scope）和大的里程碑（Miliestone）。</p>
<p>一旦主项目确定了，就需要安排不同的人做不同的模块，也就是子项目。一般团队协作有两种模式：一种是每个人负责一个子项目，从始至终；另一种是大家先一起完成基本架构，然后逐个需求、逐个模块推进，最终一起完成整个项目。</p>
<p>下面，我来谈谈两种协作模式在实践中的优缺点对比：<br>
<strong>第一种方法：每个人完成一个子项目</strong></p>
<ul>
<li>优点<br>
责任清晰，每个人都知道自己的职责，工程师也有更多的拥有感，他们可以独立负责产品的设计、实现、测试和维护，工作贯穿整个项目流程。</li>
<li>缺点<br>
如果负责某个子项目的工程师设计或者实现能力不足，由于比较独立，这个子项目很容易成为路障或者瓶颈，工程师之间也缺乏相互学习的机会。<br>
另外，因为是按人并行推进项目，需要根据每个人设置里程碑，管理的时候，技术管理者需要常常跟进每个人的进度，管理代价更高。代码审核也往往是几个有限的人参与。</li>
</ul>
<p><strong>第二种方法：所有人一起逐次完成每个模块或需求</strong></p>
<ul>
<li>优点<br>
工程师之间合作最大化，可以彼此协调、彼此学习、在对方有事的时候相互补位。项目管理有明确统一的里程碑，每个工程师都有机会接触更多的工作，每个人的代码可以有更多的人参与审核。</li>
<li>缺点<br>
每个工程师的责任划分并不是那么明显，很容易出现能者多劳、勤者多劳的现象。一些新人总是做一些执行或打杂的事，得不到锻炼。</li>
</ul>
<p>这两种模式对比来看，它们各有利弊。现实中可以根据情况组合使用。比如，两到三人合作负责一个模块，也可以在每人一个模块的基础上，将小模块合并成大模块。然后每个大模块都有技术负责人（Tech Lead），对一些能力不足的工程师给予指导和支持等等。</p>
<hr>
<h1 id="第三点每个子项目的生命周期">第三点，每个子项目的生命周期</h1>
<p>子项目一旦确认，它的生命周期就会融入到工程师的日常工作中，内容如下：</p>
<ol>
<li>
<p>开发初期的设计文档<br>
一般可以使用共享的谷歌文档（Google Docs），Quip等（国内一般用腾讯文档、石墨文档多一些）。不同的人可以编辑或评论、阅读。一般设计文档会先由组内工程师和产品经理审核，然后到大组评审（包括Legal，Compliance，Fiance等）。</p>
<p>如果涉及到公司的整体架构，还需要发给全公司审核。参与审核的人员是所有工程师。很多人会有选择的参与一些设计的审核，通常技术骨干会预留时间审核所有的技术设计文档。设计文档不仅包括怎么实现，还有选型理由、考虑的因素、支持和不支持的属性、时间线等等。</p>
</li>
<li>
<p>设计测试实验，这是可选的，如果针对某个产品需求我们想知道用户的反馈，就需要数据工程师参与设计实验，也就是A/B测试。实验中的数据埋点也会在下一步实现中完成。</p>
</li>
<li>
<p>一旦设计文档锁定，就可以开始实现了。不论是单人负责还是多人合作，实现都是按照多次代码提交（Pull Requests）来迭代的。每次代码提交都要写清楚代码改动的摘要和测试。并通知不同的工程师审核。</p>
</li>
<li>
<p>所有的实现都要加入监控、日志、预警代码。</p>
</li>
<li>
<p>所有的实现都隐藏在一个开关后。当代码就位后，就开始灰度发布。通常是先发布给几个开发人员测试，然后到项目组，然后到其它员工（Google称之为Dog Food，因为他们可以大量使用自己的产品），然后按照百分比推给用户。</p>
</li>
<li>
<p>对一些需要重构的关键产品链路，有时候也会使用双重写（Dual Write），就是新特性和就特性都写入数据库，并通过不同的方式比较两个实现的结果。只有验证结果一致时，才会将交易（Traffic）从旧实现切换到新实现。</p>
</li>
<li>
<p>最后是一些扫尾工作，包括移除用来做A/B测试和灰度发布的代码开关等，有时候还会有一些次要需求的实现。</p>
</li>
</ol>
<hr>
<h1 id="第四点主项目的生命周期">第四点，主项目的生命周期</h1>
<p>主项目的生命周期根据子项目的实现方式会有所不同，但有些特点是共有的。</p>
<ol>
<li>项目开始都有一个整体的设计文档，界定子项目的范围和相关性、时间线等等。</li>
<li>在所有子项目进行的过程中，有时候会发现一些共同需要的架构或服务，可以单独提取成公共服务或库，比如一个调度服务，或者一个幂等实现等等。</li>
<li>给相关人员做进度报告，包括主项目的里程碑。</li>
<li>由于子项目完成时间可能不一样，需要进行人员的重新配置。</li>
<li>在开发过程中不断更新文档。</li>
<li>因为不确定的需求变动，会取消或者生成新的子项目。</li>
<li>有时候，也会因为公司的方向变化或战略调整，对主项目做比较大的变更，同时对应调整相关的子项目。</li>
<li>在项目开始和结束的时候，需要做好对外的交流和沟通。一来确保自己的项目改动不会影响倒期他的项目，二来让将会依赖这个项目的产品组了解相关信息，确定计划。</li>
</ol>
<hr>
<h1 id="第五点收尾-维护-复盘">第五点，收尾、维护、复盘</h1>
<p>整个项目结束后，一般都会做一些代码清理和文档的更新和整理，有时候还需要写新的用户手册或Wiki等。一些基本的错误和异常处理要写到运维手册（Oncall Playbook）里，便于以后运维的人知道怎么处理一些已知的问题。</p>
<p>每个项目结束后都会进行复盘，总结整个项目的教训和经验。有时候还需要在组内做些演讲，让更多的人了解这个项目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】28-如何激发团队人员的责任心]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-28-ru-he-ji-fa-tuan-dui-ren-yuan-de-ze-ren-xin</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-28-ru-he-ji-fa-tuan-dui-ren-yuan-de-ze-ren-xin">
        </link>
        <updated>2019-12-06T02:58:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="如何激发团队人员的责任心">如何激发团队人员的责任心</h1>
<p>英文中有两个词很有意思：Accountability和Responsibility，大体可以翻译成“责任”，但是细细品味，却在用法上有所不同。Accountability有点儿问责、责任制的意思，是一个由外向内的原则和约定，让某一个人对某件事负责的意思；Responsibility虽然有类似的意思，但更多的是一种道德和义务上的责任心、责任感的意思。</p>
<p>在公司和团队里，这两种责任都不少见。不过Accountability不是自发的，而是通过交涉、讨论、约定，最终决定由谁来负责，并要求责任人同意负责这件事。比如保质保量按时完成某个项目中的某一个模块，是产品经理的责任，哪些需求需要使用哪些技术实现，是某个工程师的责任，等等。</p>
<p>Responsibility是责任心和责任感，是一种更强烈的自发责任，员工从内心深处觉得自己对某件事、某种集体利益和荣誉具有不可推卸的责任。公司里有一些没有具体岗位划分和衡量标准的工作，比如处理不是自己职责范畴的Bug、帮助别人答疑解惑等，具备Responsibility的人回去主动承担这些工作。</p>
<p>从某种程度上来说，责任心更多是一种抽象的概念，很难去培养，即使可以培养，也是个漫长的过程。除了员工自身的素质，公司或团队的规模和文化、公司的发展前景、员工的信息、平均水准和表现等等，都是影响责任心培养的元素；但是，责任心在团队里的作用却很大，有责任心的团队，战斗力和生命力都是异常强大的。</p>
<p>作为管理者，如何去激发团队人员的责任心呢？可以从以下三个方面考虑：</p>
<ol>
<li>明确责任制，尽可能通过规划来明确和规范责任心、责任感相关的事情；</li>
<li>让责任制变得有效，而不是形同虚设。每个人真正的对自己那块业务负起责任来；</li>
<li>尽可能地让团队成员充满归属感，进而激发他们的责任心。</li>
</ol>
<p><strong>首先说说明确责任制</strong>，怎么把一些没有明确职责范围的事变成职责呢？有一些不同的方法可以尝试。比如，适当放权，让团队人员不是负责执行一些事情，而是对某一块业务具备完全的决定权，也就是说，让他们去主导一些事情。这样员工会认为自己对项目有完整的所有权，进而具备责任心。</p>
<p>当然，由于人员的流动、项目组重组等原因，这种全权负责的项目制度还是会产生灰色地带，比如前面一个人项目做到一半就离职或者被抽调到其它组去了，那后期的Bug修复和改进要怎么做呢？</p>
<p>如果项目剩下的工作还很多，可以找一个工程师接手并担起全部责任。如果剩下的工作不多，而且很零散，可以通过一种守门员机制，组里的人每周轮流值班，负责这一周与该项目相关的各种杂活，比如处理用户反馈，修复Bug等等。</p>
<p>另外，还要有适当地激励机制，对于主动承担责任的员工表示认可和感激，适当的物质奖励也是可以的。他们自发地做了一些对团队有益的事情，承担了本不属于自己的责任，理应得到其他人的尊重。</p>
<p><strong>其次，让责任制变得有效而不是形同虚设</strong>。关键点是让责任人意识到承诺了就要努力做到，如果承诺的事没做，需要承担后果，而不是没人在意。</p>
<p>比如某个Bug引发了事故，大家只是去修复Bug，但是没人去跟进Bug是怎么产生的，造成了什么影响，后续怎么预防，那Bug就会越来越多。如果项目延期，大家只是继续延后项目完成的时间线，而不是去分析为什么延期，如何赶上进度，是否需要外部资源的支持，那期限就会变得可有可无。</p>
<p>有效的责任制，在开始的时候就要让所有人明确责任与权力，而不是最后追究责任或推卸责任。</p>
<p>在这个基础上，根据每个人不同的情况，在执行过程中适度跟进。发现问题的时候，及时指出来，但这时需要的是，管理者要用关心的口吻，而不是追求的态度，让对方了解到问题出在哪里。不要因为做好人而什么都不说，那样只会让小问题扩散成大问题。多花时间，让对方认识到问题所在，而不是把你的主观感觉强加于人，用引导的方式，会更好的激发团队责任心。</p>
<p>不要变成一个微观管理者，也不要成为一个纯粹的规则执行者。那样对团队人员的责任感、上进心和积极性等，都有害无益。</p>
<p><strong>最后谈谈归属感</strong>。归属感是指某个人对某样事物、组织的从属感觉，是一种主观的个人感受。</p>
<p>比如一个对公司有归属感的人，会对公司产生一种“家”的感觉，觉得自己是公司的一分子，会非常在意公司发生的一切，并希望公司发展得更好，自己也会有更多的空间；相反，如果员工对公司没有归属感，始终会认为自己是这个公司的过客，总有一天会离开的，自然也谈不上什么责任心，能够做一天和尚撞一天钟就不错了如何增加员工的归属感呢？首先要在有利公司发展的基础上建立独特的企业文化，创新、公开透明、积极向上，这些因素可以留住更优秀的员工。需要强调的是，公司不是温情脉脉的家，公司是一艘大船，有了方向，大家合力划桨，才能到达理想的彼岸。想要优秀的人产生归属感，仅仅靠丰厚的薪酬待遇和舒适的工作环境是不够的，他们还需要远大的目标和坚定的信念，只有真正伟大的创见，才能让这些优秀的人与公司一起往前走。除此之外，管理者还应该以身作则，让员工看到自己的努力，对公司目标的追求，对企业文化的践行。真诚对人，能够从员工角度考虑问题，对好的行为认可并加以鼓励，同时做一些仪式感比较强的团队活动和建设，都是增加员工归属感的好方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】26-如何做自己的职场规划]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-26-ru-guo-zuo-zi-ji-de-zhi-chang-gui-hua</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-26-ru-guo-zuo-zi-ji-de-zhi-chang-gui-hua">
        </link>
        <updated>2019-12-03T03:26:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-在做职场规划前自己需要考虑什么">一、在做职场规划前自己需要考虑什么？</h1>
<p><strong>做一个职场规划时，你作为当事人，自己先要想清楚很多问题，然后再和你领导交流沟通，寻求他的支持和帮助。</strong></p>
<p>那么，下面的问题是你首先要考虑的：</p>
<ol>
<li>你的个人价值观是什么，最在意什么？换句话说，什么样的情境或者状态会让你有幸福感或者自信心。比如，在你的成长路上哪些是你在意的，是独立解决问题的能力，还是挑战别人做不到的事情；是受欢迎程度，和所有人有良好的关系，还是更在意自由、健康的家庭生活。</li>
<li>你的长期愿景是什么，五年甚至十年后，你希望自己成为一个什么样的人？</li>
<li>为了达到目标，你还需要哪些技能或经验？你可以在短期内发展什么技能让你走得更远？想达成你的梦想职业，或者在工作中取得成功，你还需要做什么，需要哪些必备的计能？哪些计能对你来说不是必须的，但是会有很大好处？</li>
<li>你的优势和长处是什么？是合作性、独立思考、行动快速，还是有良好的产品思维。你现在的日常工作能否让你展示自己的长处，又是如何展示的，你觉得你比别人在哪些方面做的好，能不能举出写具体的例子？</li>
</ol>
<p>当你想清楚以上问题的时候，大概就知道自己想要什么了。如果你是一个管理者，也可以试着用这些问题去启发你的团队队员。</p>
<hr>
<h1 id="二-需要领导提供什么样的支持">二、需要领导提供什么样的支持？</h1>
<p>在思考完自己的问题后，接下来，也就是最重要的问题就是：<strong>你需要你的领导者提供什么样的支持？</strong><br>
例如:</p>
<ol>
<li>需要一个能够证明自己的项目；</li>
<li>需要一个能带自己的老员工，这个员工可能是你的榜样（Role Model），也可能是为你提供日常指导的人；</li>
<li>需要更多练手的机会；</li>
<li>需要专注培养自己的某一项技能；</li>
<li>需要让自己接触更多的业务或者架构相关的讨论；</li>
<li>需要参加一个系统的培训。</li>
</ol>
<p>在这些问题或者要求提出之前，你应该考虑到领导者的资源和整体项目进度，也就是说，领导者在提供这些支持之前，很可能会有一些限制或者要求。</p>
<p>比如，你想要一个能证明自己的项目，那么在你承担重任之前，可能需要完成另外一些不那么重要的项目，甚至是脏活累活来证明自己。这种情况下，沟通的关键就是契约，你需要如何证明自己，才能去做自己喜欢的项目，组里是不是有人明显比你胜任的多？</p>
<p>比如，你需要一个能够带着自己往前走的老员工，那你就要知道，对新人的指导会花费老员工很多时间和精力，当你这样要求的时候，是不是可以提供一些力所能及的回馈呢？比如主动帮助老员工做一些他手上的杂活，也可以把老员工传授给你的经验写成文档，这样，你被指导了一次，却留下了以后新人都能使用的文档资源。老员工会更愿意去带这样的新人。</p>
<p>比如，你想接触更多业务和架构相关的讨论，那你是否按时完成了自己的本职工作？如果你自己很勤奋，虽然参与了各种讨论，但自己的工作完成得又快又好，甚至利用自己的休息或娱乐时间做了一部分工作，这样领导者才不会有顾虑。如果你作为新人，该做的工作没做，整天参加各种讨论开眼界，这让领导者怎么管理团队里的其他人呢？</p>
<p>在这个过程中，作为员工，不要提过于脱离实际的要求。作为管理者，要明确的让对方了解不让他承担这个项目的理由是什么，风险在哪里，让对方知道自己的不足，并提供机会让他先提升这方面的技能。</p>
<p>你和你的领导都应该明确，所有的支持和帮助对你的长期目标和短期发展都是有益的。不要提一些似是而非的需求，也不要人云亦云，如果这些要求不会让你离你的目标越来越近，那就是无用功。</p>
<p>得到领导者的支持和帮助后，剩下的就是让这一切变得可执行和可追踪。你可以和你的领导一起为你的“成功”或“进步”定义一些可测量的标准，制定可执行的行动计划，然后记录你的发展，按时和你的领导进行一对一沟通，讨论你的进步，反省做的不够和不好的地方。需要的话，你可以适时地调整你的计划，完成自我发展。</p>
<hr>
<h1 id="总结">总结</h1>
<p>如何做自己的职场规划？我们来总结一下，你需要完成以下四个步骤：</p>
<ol>
<li>知道自己想要什么，知道现在的你和理想的你差距在什么地方；</li>
<li>和领导者沟通，得到一些有前提或者回馈的支持或帮助；</li>
<li>设定目标，制定一个你和你的领导都同意的计划和期限，确保计划会让你和目标更接近；</li>
<li>让计划变得可执行和可追踪，按部就班的完成和跟进，同时根据情况调整不合理或者不完善的地方，持续改进。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】25-兼容并包的领导方式]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-25-jian-rong-bing-bao-de-ling-dao-fang-shi</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-25-jian-rong-bing-bao-de-ling-dao-fang-shi">
        </link>
        <updated>2019-12-02T08:27:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>你可能听说，很多硅谷公司都有个不成文的规定，叫做“多样化（Diversity）”，这是什么意思呢？<br>
简单来说，就是要求公司在招聘人才的时候，尽可能保持员工组成的多样化。</p>
</blockquote>
<hr>
<h1 id="一-为什么要保持员工组成的多样化">一、为什么要保持员工组成的多样化？</h1>
<p>第一个原因是，互联网时代的市场组成是多样化的。很多欧美产品在中国市场的销售额是公司营收的主要组成部分，国内很多产品也都开始具备国际化意识，逐步介入欧美中东等地区的市场。</p>
<p>并且，硅谷地区的人口结构和美国整体是不同的，多次殖民和移民的历史，让硅谷的人口本身就呈现多样化，也因此硅谷公司的国际化视角从创建之初就有了。</p>
<p>在思维方式上，我们希望在构建产品的时候就开始兼顾市场的多样化，比如考虑设计、本地化、语言、使用习惯等等，而多样化的员工可以更好地帮助实现产品多样化的功能特性。</p>
<p>第二个原因是，产品的用户也是多种多样的。每个客户会希望产品具有个性化特性，也就是有“这个特性感觉上是为我做的，更适合我使用”的需求。因此，要保持产品的竞争力，就需要了解更多客户的不同需求。</p>
<p>产品或者平台怎样才能让每个用户都能体验到想要的个性化呢？这就要求设计者必须意识到用户的多样化和需求的差异化，也就从根本上要求了组成设计者的员工是多样化的。</p>
<hr>
<h1 id="二-如何才能保持员工的多样化">二、如何才能保持员工的多样化？</h1>
<p>首先，多样化可以体现在国际、性别和人种这种外部区别上，比如：白种人、黄种人、黑人都要保持一定的比例；性别上也要求保持平衡，也就是比较健康的男女员工数量。还有一些公司会要求有一定比例的同性恋、不同类型的宗教徒等等。</p>
<p>其次，员工的多样化也可以体现在团队内部的差异上，互联网时代需要多种多样的人才，人才库的组成也应是多元化的。一个团队里，需要具备开创性思维、敢打敢拼的人，也需要一些能够深思熟虑，以及能够把事情落地和执行的人。</p>
<p>最后，员工的多样化也体现在团队的创新思维上。一个公司，如果有一个Idea，一个产品，那么这个公司早晚会被时代的大潮抛弃。比尔·盖茨曾经说过：“组织要么创新，要么死亡”，就是这个道理。</p>
<p>因此，团队内部需要有创新者，或者是“异见人士”的存在，他们的思路和见解并不是总和产品的主要设计者保持一致；这种情况下，团队很难“想到一块去”，也就保持了团队创新的活力。</p>
<p>有一些不同的声音，对于“哪些重要，哪些该做”有些不同的看法，哪怕这些方法在初期会被认为风险太高、太离谱，但在某种程度上，它们会让团队的活力更持久。</p>
<hr>
<h1 id="三-领导需要具备兼容并包的思维">三、领导需要具备兼容并包的思维</h1>
<p><strong>多样化的员工组成保证了多样化的企业文化，所以在很多时候，这也要求领导者要具备兼容并包的思维。</strong></p>
<p>“包容性领导的六个特征”（The six signature traits of inclusive leadership）一文中提出了一种新的领导方式，文中认为领导者应该具备以下六种计能或特征：</p>
<ol>
<li>坚定的承诺<br>
领导者需要从内心深处认为多样化和融合是一个正确的人生观和价值观。保持开放接纳的心态，平等对待每一种人和文化，对企业有益。</li>
<li>谦卑的勇气<br>
领导者不要有盲目的自我优越感，而应该客观的看待自己的优点和缺点。对待他人都要保持一种谦虚的态度，无论他们是何种教育背景、人种、性别。</li>
<li>正确的认知<br>
领导者需要知道自己和企业有盲点、有偏见，知道问题出在哪，知道解决问题的方向。</li>
<li>开放的心态<br>
领导者需要真诚地渴望了解不同人的看法，可以接受别人的一些价值观，并且知道所有的事务都有一定程度的不确定性。</li>
<li>高情商<br>
领导者能够和不同职位不同职业背景的人愉快合作和交流。哪怕不是百分之百的认可，也可以很专业地处理。</li>
<li>合作的意愿<br>
给每个人施展的机会和空间，提供公平和安全感，哪怕这意味着额外的代价和麻烦。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】24-编程语言漫谈]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-24-bian-cheng-yu-yan-man-tan</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-24-bian-cheng-yu-yan-man-tan">
        </link>
        <updated>2019-12-02T02:23:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1初学者不要纠结先学哪种语言">1.初学者不要纠结“先学哪种语言”</h2>
<p>初学者在先学哪种语言上花费时间纠结很不值得，还不如随便挑选一个语言，跳进去游几圈试试。对于工程师来说，学会第一种编程语言只是万里长征的第一步，只要你还在这个领域，就不可能只学习一种语言，只会一种语言的工程师根本不能称之为工程师。</p>
<hr>
<h2 id="2只有先掌握好一种语言才能快速学好其它语言">2.只有先掌握好一种语言，才能快速学好其它语言</h2>
<p>如果你不能用一种编程语言的基本特性写好代码，那换成另外一种语言也无济于事，你会写出同样差的代码。比如，你的Java很糟糕，那么换成Go、Ruby，你的代码也会同样糟糕、甚至更差。</p>
<hr>
<h2 id="3脚本语言也可以作为入门语言">3.脚本语言也可以作为入门语言</h2>
<p>很多人觉得不要用脚本语言入门，我觉得不一定，尤其是现在就着人工智能的浪潮搞机器学习的人，用Python入门就挺好。另外，脚本语言在面试中占优势。平时找工作Ruby、Python、C++和Java熟练度差不多，但面试中使用Ruby或者Python答题，写代码的时间估计是两者的一半。</p>
<hr>
<h2 id="4不要有明确的前后端分隔">4.不要有明确的前后端分隔</h2>
<p>后端工程师要熟练掌握一门前端语言，前端工程师也要熟练掌握一门后端语言。倒不是为了提倡全栈或多能力储备，而是两者的编程思维模式很不一样。知己知彼，在架构设计和解决具体问题时，才会更精确的判断。</p>
<p>另外，现在大前端的概念也比较流行，也就是大前端工程师能同时掌握Web编程语言、iOS和Android编程语言，原生技术（iOS和Android）和Web的配合越来越紧密。</p>
<hr>
<h2 id="5sql是一门非常重要并且应该熟练掌握的语言虽然它不能被称为编程语言">5.SQL是一门非常重要并且应该熟练掌握的语言（虽然它不能被称为编程语言）</h2>
<p>如果你平时的编程工作中涉及到业务功能，而不是纯粹的技术架构，一定会使用到数据库。SQL就是数据的语言，通过它，你可以和数据建立连接和沟通。</p>
<p>如果你数据访问模式写的很差，轻则代码性能一塌糊涂，重则引发Bug，而涉及数据的问题，Bug等级都比较高，后果可能很严重。</p>
<hr>
<h2 id="6工程师要具备搭建测试框架的能力">6.工程师要具备搭建测试框架的能力</h2>
<p>无论什么语言，工程师都应该能够基于这种语言搭建测试框架，写好测试代码和写业务代码一样重要，甚至更重要。工作后你会发现，可能有时候我们只花五分钟写了一个程序，而为其写一个能差不多覆盖所有功能路径的测试用例集却花了一个小时。</p>
<hr>
<h2 id="7在任何时候都要用并发的-分布式的思维去看待你的程序">7.在任何时候都要用并发的、分布式的思维去看待你的程序</h2>
<p>因为竞争条件或者并发中的不确定因素（比如调用顺序）导致的Bug，仅仅理解语言的基本特性，根本不能解释。</p>
<p>每种语言都有自己的并发编程模式（比如Go的Goroutine，Java的ForkJoinPool，Swift的Swift Grand Central Dispatch等）。学习每一种语言，都应该深入了解它的并发模型，在这个多核的时代，不懂并发的程序员不可能是个好工程师。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】23-如何处理工作中的人际关系？]]></title>
        <id>https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-23-ru-he-chu-li-gong-zuo-zhong-de-ren-ji-guan-xi</id>
        <link href="https://iflytek-duan.github.io//post/zhu-yun-de-ji-zhu-guan-li-23-ru-he-chu-li-gong-zuo-zhong-de-ren-ji-guan-xi">
        </link>
        <updated>2019-11-27T08:18:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>当我们初入职场时，职能级别可能比较低，大部分工作会比较独立，即使不是特别善于处理各种人际关系，问题也不算大，一来你不用协调资源，独立工作会占主要部分，很多时候都是处于闷头做事的状态中；二来，组里会有一些老员工，可以帮助你做各种沟通工作。<br>
但是，若想职场进阶，一直往前走，到了某个阶段，比如需要你去做更多的协调和沟通工作而不仅仅是写代码的时候，如何处理人际关系就成了一项必不可少的软技能，重要性不比技术上的硬计能低。</p>
</blockquote>
<hr>
<h1 id="如何更好的处理工作中的人际关系">如何更好的处理工作中的人际关系</h1>
<ul>
<li>
<p><strong>首先，对于自己的上下级，保持开放的心态和愿意沟通的态度十分重要</strong><br>
上下级是在职场中最无法避免的人际关系，因为各人性格不同，可能你和有些人更容易在看法和决策上达成一致，而有些人则经常不能很好的理解别人的意图，需要多次沟通，采用对应的沟通方式。上下级之间的利益关系大多时候是绑在一起的，如果处理不好，对彼此的工作有很大的影响不说，很多时候还会发生不愉快的事情。</p>
</li>
<li>
<p><strong>其次，在交往过程中，尽可能地对别人分享、工作、交流持一种积极、友善和鼓励的态度</strong><br>
我们常常把处理人际关系的态度分为三类。第一类是给予者，这类人，不怎么计较得失，总是尽最大可能的去帮助和支持别人。第二类人秉承对等关系，谁对他好，他就对谁好，自己帮了别人一次，或者别人帮了自己，都是一个人情，都会记在内心的小本本上，那是一个无形的账本。第三类人是索取者，这种人只会跟对自己有帮助的人接触，做的事也是从自身的利益出发。</p>
<p>当提到这三种人时，我们脑海里可能会浮现出一些人物形象并对号入座，甚至还会想到现实中这样的例子。对于自身来说，大部分时候我们会认为自己是第一类人，也可能是第二类人，或者是介于第一跟第二类人之间，总之，绝对不会认为自己是第三类人。</p>
<p>这其实说明了人们的潜意识里都认可第一类是最积极向上的处世之道，然而在现实中，因为能力、对方态度、利益关系等各种因素，我们能表现出来的“不计较得失”就可能有很大的局限性。</p>
<p>如果我们每个人都向“给予者”的方向努力，那么便容易建立一个正能量满满的工作环境，与别人的交流也会更加顺畅。</p>
</li>
<li>
<p><strong>第三，加入一些有利于自己成长的社交圈子</strong><br>
比如特定技术有共同的兴趣社区，对摄影、读书有共同爱好的小组等。这些圈子可能很大很正式，比如一些商业组织，也可以是几个有共同困难或者目标的同事组成的微信群，平时进行一些非常随意的常规讨论。</p>
</li>
<li>
<p><strong>第四，是当地寻求帮助</strong><br>
很多时候主动向另一个人表示你需要他的帮助，其实会很巧妙的增加两个人的亲密度。当然，不要问不值得问的问题，注意是不是会耽误对方太多的时间，自己的态度也尽可能的开放、谦逊。</p>
<p>反之，如果别人向你寻求帮助，尽可能耐心地协助对方解决问题，如果很忙或者时机不对，就告诉对方，并问是不是可以换个时间。如果对方比你资历浅，或者问的问题太简单，也不要摆架子或者显得很不耐烦。</p>
</li>
<li>
<p><strong>第五，对于别人的意见要尽可能的认真对待</strong><br>
即使没有任何实际行动，也让对方明白你的想法，为什么你没有采纳他的意见。自己给别人的意见也要诚恳，如果是个人看法，不要强迫于人，尤其不要拿一些理论上有争议的看法强迫别人接受，比如哪个设计模式更好。如果是真实案例里并且会影响到项目进展的对错，尽可能地摆事实举例子让对方明白你的想法和出发点，本着把事情做好的原则去沟通。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>