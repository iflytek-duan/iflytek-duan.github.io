<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iflytek-duan.github.io/</id>
    <title>紫豪的Blog</title>
    <updated>2020-08-31T10:01:14.448Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://iflytek-duan.github.io/"/>
    <link rel="self" href="https://iflytek-duan.github.io/atom.xml"/>
    <subtitle>You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.</subtitle>
    <logo>https://iflytek-duan.github.io/images/avatar.png</logo>
    <icon>https://iflytek-duan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 紫豪的Blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】代码混淆]]></title>
        <id>https://iflytek-duan.github.io/post/android-dai-ma-hun-yao/</id>
        <link href="https://iflytek-duan.github.io/post/android-dai-ma-hun-yao/">
        </link>
        <updated>2020-07-01T02:34:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-app混淆配置">一、App混淆配置</h1>
<p><strong>1. 基础的指令配置</strong></p>
<pre><code class="language-java">-optimizationpasses 5 # 指定代码的压缩级别
-dontusemixedcaseclassnames # 混淆后类名都为小写
-dontskipnonpubliclibraryclasses #指定不去忽略非公共的库的类
-dontskipnonpubliclibraryclassmembers #指定不去忽略非公共的库的类的成员
-dontpreverify # 不做预校验的操作
-verbose # 混淆时是否记录日志
-printmapping proguardMapping.txt #生成原类名和混淆后的类名的映射文件
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  # 混淆时所采用的算法
-keepattributes *Annotation*,InnerClasses #不混淆Annotation
-keepattributes Signature #不混淆泛型
-keepattributes SourceFile,LineNumberTable #抛出异常时保留代码行号
-ignorewarnings #抑制警告
</code></pre>
<p><strong>2. 一些通用的必要配置</strong></p>
<pre><code class="language-java">#系统类不需要混淆
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingS
-keep class android.support.** {*;}
-keep public class * extends android.app.Fragment

-keepclasseswithmembernames class * {  # 保持 native 方法不被混淆
    native &lt;methods&gt;;
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆
    public void *(android.view.View);
}
-keepclassmembers enum * {# 保持枚举 enum 类不被混淆
    public static **[] values();
    public static ** valueOf(java.lang.String);
}
-keep public class * extends android.view.View{# 保持View类不被混淆
    *** get*();
    void set*(***);
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclasseswithmembers class * {# 保持自定义控件类不被混淆
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆
    public static final android.os.Parcelable$Creator *;
}
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}
-keep class **.R$* {
 *;
}
-keepclassmembers class * {
    void *(**On*Event);
}

#WebView相关
-keepclassmembers class fqcn.of.javascript.interface.for.Webview {
   public *;
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String);
}

# 其它
-keep class com.google.android.gms.** {*;}
-dontwarn com.google.android.gms.**
-dontwarn com.viewpagerindicator.*
-dontwarn com.amazonaws.**
-dontnote com.google.vending.licensing.ILicensingService
-dontnote com.android.vending.licensing.ILicensingService


# Androidx相关
-keep class com.google.android.material.** {*;}
-keep class androidx.** {*;}
-keep public class * extends androidx.**
-keep interface androidx.** {*;}
-dontwarn com.google.android.material.**
-dontnote com.google.android.material.**
-dontwarn androidx.**
</code></pre>
<p><strong>3. 实体类</strong></p>
<pre><code class="language-java"># 可能会存在多处，需要一一添加
-keep class 包名.bean.** {*;}
</code></pre>
<p><strong>4. 第三方Library</strong></p>
<pre><code class="language-java"># 本地.so库文件声明
-libraryjars libs/armeabi/xxx.so
-libraryjars libs/armeabi-v7/xxx.so
-libraryjars libs/x86/xxx.so

# 常用第三方Library混淆配置
# Glide
-keep public class * implements com.bumptech.glide.module.GlideModule
-keep public class * extends com.bumptech.glide.module.AppGlideModule
-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
  **[] $VALUES;
  public *;
}

# Alipay
-dontwarn com.alipay.**
-dontwarn com.ta.utdid2.**
-dontwarn com.ut.device.**
-dontwarn android.net.**
-keep class com.alipay.** {*;}
-keep class com.ta.utdid2.** {*;}
-keep class com.ut.device.** {*;}
-keep class android.net.SSLCertificateSocketFactory

# butterknife
-keep class butterknife.** {*;}
-dontwarn butterknife.internal.**
-keep class **$$ViewBinder {*;}
-keepclasseswithmembernames class * {
    @butterknife.* &lt;fields&gt;;
}
-keepclasseswithmembernames class * {
    @butterknife.* &lt;methods&gt;;
}

# eventbus
-keepattributes *Annotation*
-keepclassmembers class ** {
    @com.google.common.eventbus.Subscribe &lt;methods&gt;;
        public void onEvent*(**);
        void onEvent*(**);
}
-keep enum de.greenrobot.event.ThreadMode {*;}
-keepclassmembers class * extends de.greenrobot.event.util.ThrowableFailureEvent {
    &lt;init&gt;(java.lang.Throwable);
}

# Gson
-dontwarn com.google.gson.**
-keep class com.google.gson.** {*;}
-keep class sun.misc.Unsafe {*;}

# 科大讯飞相关(ifly_push_sdk &amp;&amp; Msc)
-dontwarn com.iflytek.**
-keep class com.iflytek.** {*;}

# 腾讯相关(libammsdk &amp;&amp; open_sdk)
-dontwarn com.tencent.**
-keep class com.tencent.** {*;}

# weibosdkcore
-dontwarn com.sina.weibo.sdk.**
-keep class com.sina.weibo.sdk.** {*;}

# Dagger
-dontwarn dagger.internal.codegen.**
-dontwarn javax.inject.**
-keepclassmembers,allowobfuscation class * {
    @javax.inject.* *;
    @dagger.* *;
    &lt;init&gt;();
}
-keep class dagger.** {*;}
-keep class javax.inject.** {*;}
-keep class * extends dagger.internal.Binding
-keep class * extends dagger.internal.ModuleAdapter
-keep class * extends dagger.internal.StaticInjection

</code></pre>
<blockquote>
<p>这里要注意的一点是，要避免重复声明jar包——如果在build.gradle中使用了<code>compile fileTree(include: ['*.jar'], dir: 'libs')</code>，就不需要在混淆文件中添加<code>-libraryjars libs/xxx.jar</code>去声明对应的jar了，否则会报错提示重复添加。</p>
</blockquote>
<p><strong>5. 反射类及其相关方法</strong></p>
<pre><code class="language-java">-keep class java.lang.annotation.** {*;}
</code></pre>
<p><strong>6. JS相关交互类(方法互调)</strong></p>
<pre><code class="language-java"></code></pre>
<hr>
<h1 id="二-moduleaar-lib混淆配置">二、Module（aar、lib)混淆配置</h1>
<blockquote>
<p>我们在封装<code>aar、lib</code>提供给他人使用时，为了保证功能能够正常的被使用，往往需要告知别人针对<code>aar、lib</code>进行免混淆配置以保证<code>aar、lib</code>中的一些关键类不被混淆以免影响正常使用。（github上很多Library的README.md文件中都有对应的混淆清单提示）<br>
但是在实际的使用过程中，经常有用户会忘记在<code>App</code>中进行对应的<code>aar、lib</code>的免混淆配置，导致其功能不能正常使用（打包后关键类被混淆），这样的的操作是很不友好的。</p>
</blockquote>
<p><strong>AndroidStudio</strong>在3.x之后，其实已经为我们提供了新的解决办法，在新建<code>Module</code>后，我们会发现<code>Module</code>下有了<code>proguard-rules.pro</code>、<code>consumer-rules.pro</code>两个文件，而在<code>Module/build.gradle</code>配置文件的<code>defaultConfig</code>中，我们会发现有个<code>consumerProguardFiles</code>配置，它其实就是为了解决<code>aar、lib</code>混淆配置后<code>App</code>没有进行对应的配置导致<code>aar、lib</code>的配置未生效的问题。</p>
<p><strong>正确的解决方案（只需在aar、lib中进行对应的混淆配置，即便引用的App在混淆时不针对aar、lib进行对应的配置，打包后也不会影响aar、lib的正确混淆）：</strong><br>
在<code>Module/build.gradle</code>中配置（Android 3.x后会默认生成该配置）：</p>
<pre><code class="language-java">android {
    defaultConfig {
        consumerProguardFiles 'consumer-rules.pro'
    }
}
</code></pre>
<p>然后在在<code>Module/consumer-rules.pro</code>文件中进行具体的混淆配置。</p>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="http://blog.csdn.net/hudan2714/article/details/53191782">整理Android最全的混淆规则大全（最新的开源框架混淆）</a><br>
<a href="http://blog.csdn.net/qq_15807167/article/details/52683375">Android混淆</a><br>
<a href="https://blog.csdn.net/lhd201006/article/details/72913071">Android Studio的Proguard（代码混淆）</a><br>
<a href="https://www.v2ex.com/t/646787">Android 配置中的 consumerProguardFiles</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（四）集合框架]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-si-ji-he-kuang-jia/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-si-ji-he-kuang-jia/">
        </link>
        <updated>2020-06-19T06:24:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-概述">一、概述</h2>
<p><strong>Kotlin中集合框架相对于Java：</strong></p>
<ol>
<li>增加了“不可变”集合框架的接口；</li>
<li>没有另起炉灶，复用Java API的所有实现类型；</li>
<li>提供了丰富易用的方法，例如<code>forEach/map/flatMap</code>；</li>
<li>运算符级别的支持，简化了集合框架的访问。</li>
</ol>
<hr>
<h2 id="二-集合框架的接口类型对比">二、集合框架的接口类型对比</h2>
<table>
    <tr>
        <th></th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>不可变List</th>
        <th>List&lt;T&gt;</th>
        <th rowspan="2">List&lt;T&gt;</th>
    </tr>
    <tr>
        <th>可变List</th>
        <th>MutableList&lt;T&gt;</th>
    </tr>
    <tr>
        <th>不可变Map</th>
        <th>Map&lt;K,V&gt;</th>
        <th rowspan="2">Map&lt;K,V&gt;</th>
    </tr>
    <tr>
        <th>可变Map</th>
        <th>MutableMap&lt;K,V&gt;</th>
    </tr>
    <tr>
        <th>不可变Set</th>
        <th>Set&lt;T&gt;</th>
        <th rowspan="2">Set&lt;T&gt;</th>
    </tr>
    <tr>
        <th>可变Set</th>
        <th>MutableSet&lt;T&gt;</th>
    </tr>
</table>
<blockquote>
<p>注：Mutable标识可变的。</p>
</blockquote>
<hr>
<h2 id="三-集合框架的创建">三、集合框架的创建</h2>
<p><strong>1.List的创建</strong></p>
<ul>
<li>Java中创建List<pre><code class="language-java">  List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));
</code></pre>
</li>
<li>Kotlin中创建List<pre><code class="language-kotlin">  // 不可变List：不能添加或者删除元素
  val intList: List&lt;Int&gt; = listOf(1, 2, 3)

  // 可变List：可以添加或者删除元素
  val intList2: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)
</code></pre>
</li>
</ul>
<p><strong>2.Map的创建</strong></p>
<ul>
<li>Java中创建Map<pre><code class="language-java">   Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;zhangsan&quot;, 20)；
</code></pre>
</li>
<li>Kotlin中创建Map<pre><code class="language-kotlin">   // 不可变
    // &quot;name&quot; to &quot;zhangsan&quot;，这里可以理解为K-V(Key to Value)即可
    // Any等价于Java中的Object
    val map: Map&lt;String, Any&gt; = mapOf(&quot;name&quot; to &quot;zhangsan&quot;, &quot;age&quot; to 22)

    // 可变
    val map2: MutableMap&lt;String, Any&gt; = mutableMapOf(&quot;name&quot; to &quot;zhangsan&quot;, &quot;age&quot; to 22)
</code></pre>
</li>
</ul>
<hr>
<h2 id="四-集合实现类服用与类型别名kotlin特性">四、集合实现类服用与类型别名(Kotlin特性)</h2>
<p>以下是集合对应的类型别名：</p>
<pre><code class="language-java">    typealias ArrayList&lt;E&gt; = java.util.ArrayList&lt;E&gt;
    typealias LinkedHashMap&lt;K, V&gt; = java.util.LinedHashMap&lt;K, V&gt;
    typealias HashMap&lt;K, V&gt; = java.util.HashMap&lt;K, V&gt;
    typealias LinedHashSet&lt;E&gt; = java.util.LinedHashSet&lt;E&gt;
    typealias HashSet&lt;E&gt; = java.util.HashSet&lt;E&gt;
</code></pre>
<hr>
<h2 id="五-集合框架的修改">五、集合框架的修改</h2>
<ol>
<li><strong>添加元素</strong>
<ul>
<li>java<pre><code class="language-java">   for(int i = 0; i&lt; 10; i++){
           stringList.add(&quot;num:&quot; + i);
   }
</code></pre>
</li>
<li>kotlin<pre><code class="language-kotlin">   for(i in 0 .. 10){
       stringList += &quot;num:$i&quot;
   }
</code></pre>
</li>
</ul>
</li>
<li><strong>移除元素</strong>
<ul>
<li>java<pre><code class="language-java">   for(int i = 0; i&lt; 10; i++){
           stringList.remove(&quot;num:&quot; + i);
   }
</code></pre>
</li>
<li>kotlin<pre><code class="language-kotlin">   for(i in 0 .. 10){
       stringList -= &quot;num:$i&quot;
   }
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="六-集合框架的读写">六、集合框架的读写</h2>
<ul>
<li>java</li>
</ul>
<pre><code class="language-java">    // List的读写
    stringList.set(3, &quot;HelloWorld&quot;);
    String valueAt3 = stringList.get(3);

    // Map的读写
    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;Hello&quot;, 10);
    System.out.println(map.get(&quot;Hello&quot;));
</code></pre>
<ul>
<li>kotlin</li>
</ul>
<pre><code class="language-kotlin">    // List的读写
    stringList[3] = &quot;HelloWorld&quot;
    val valueAt3 = stringList[3]

    // Map的读写
    val map = HashMap&lt;String, Int&gt;()
    map[&quot;Hello&quot;] = 10
    println(map[&quot;Hello&quot;])

    // []内的值实际上就是key
</code></pre>
<hr>
<h2 id="七-pair">七、Pair</h2>
<p>Pair表示两个值的通用对（键值对），这个是Kotlin独有的。</p>
<pre><code class="language-java">    val pair = &quot;Hello&quot; to &quot;Kotlin&quot;
    val pair2 = Pair(&quot;Hello&quot;, &quot;Kotlin&quot;)
    val first = pair.first
    val second = pair.second

    // 解构表达式，相当于把pair拆分给x,y
    val (x, y) = pair
</code></pre>
<hr>
<h2 id="八-triple类似pair用于三个元素的键值对维护">八、Triple（类似Pair，用于三个元素的键值对维护）</h2>
<pre><code class="language-java">    val triple = Triple(&quot;x&quot;, 2, 3.0)
    val first = triple.first
    val second = triple.second
    val third = triple.third
    val (x, y, z) = triple
</code></pre>
<p>--</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Gradle之多类型、类型包名后缀、源集（对应文件资源）配置]]></title>
        <id>https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/</id>
        <link href="https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/">
        </link>
        <updated>2020-06-10T01:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>一般情况下，我们的开发环境分为<code>debug</code>与<code>release</code>两个环境，这个一般在新建Android项目时，Gradle文件中已完成了默认的配置，代码如下（<code>debug</code>默认存在）：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
}
</code></pre>
<p>那么，如果我们在有的项目中需要配置其它环境（如alpha、beta等），这个时候就需要额外的配置了。</p>
<hr>
<h2 id="buildtypes配置构建类型">buildTypes（配置构建类型）</h2>
<p><code>buildTypes</code>位于<code>app-build.gradle</code>文件的<code>android{}</code>代码块中，它是用来创建和配置app的构建类型的，新建一个项目在模块的<code>build.gradle</code>文件中会默认生成<code>debug</code>与<code>release</code>两个环境版本。</p>
<hr>
<h2 id="多类型配置与其作用">多类型配置与其作用</h2>
<p>当我们app需要在不同的环境下生成对应的版本时，这个时候就需要在<code>buildTypes</code>内进行对应版本类型的配置工作（如：网络baseUrl的配置），示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-release.**/&quot;'
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }

    alpha {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-alpha.**/&quot;'
    }

    beta {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-beta.**/&quot;'
    }
}
</code></pre>
<p>通过如上配置，我们可以实现针对不同的环境创建对应的版本类型。</p>
<blockquote>
<p>通过Gradle-&gt;app-&gt;build-&gt;assemble可以一键进行所有类型版本的构建，生成对应的apk文件。</p>
</blockquote>
<hr>
<h2 id="applicationidsuffix">applicationIdSuffix</h2>
<p>该字段表示，在不改变当前程序默认ID（包名）的情况下，为其添加后缀。如：当前包名是<code>com.zihao.app</code>，如果你想区分测试包与线上包的情况，这个时候在<code>buildTypes-&gt;debug</code>中将<code>applicationIdSuffix</code>设置为<code>applicationIdSuffix &quot;.debug&quot;</code>，那么对应的包名就变成了<code>com.zihao.app.debug</code>，示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    ...
    debug {
        applicationIdSuffix &quot;.debug&quot;
    }
}
</code></pre>
<hr>
<h2 id="源集source-sets构建">源集（Source Sets）构建</h2>
<p>Android Studio会为每个模块将源代码和资源文件组成一个逻辑上的源集。每个模块的<code>main/</code>源集包括所有构建变种都是用的源码和资源。其它源集的目录是可选的，Android Studio不会自动为你创建他们，当你构建新的变种的时候。但是，构建具体的app版本的时候，创建于<code>main/</code>类似的源集，可以帮助组织Gradle应该使用的文件和资源（有助于让Gradle只应在构建特定应用版本时使用的文件和资源井然有序）。</p>
<blockquote>
<p>通常源代码是放在'src/main'文件目录下的，但是你可以根据不同的构建类型（比如debug、release、alpha等）区分不同的源文件，这样对应建立的文件夹就是一个不同的构建源。打个比方，<code>debug</code>的构建源为<code>src/debug</code>，<code>release</code>的构建源为<code>src/release</code>，而在<code>src/main</code>定义的为公共资源，最后在构建时进行合并操作。</p>
</blockquote>
<p><strong>构建源的命名规则如下</strong></p>
<ul>
<li><code>src/main/</code><br>
此源集包括所有构建变体共用的代码和资源。</li>
<li><code>src/&lt;buildTypes&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>buildType</code>使用的代码和资源。示例：<code>src/alpha</code>。</li>
<li><code>src/&lt;productFlavor&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>productFlavor</code>使用的代码和资源。示例：<code>src/baidu</code>。</li>
<li><code>src/&lt;productFlavorBuildType&gt;/</code><br>
创建此源集可加入特定构建变体专用的代码和资源。</li>
</ul>
<p>例如，要生成应用的“baiduDebug”版本，构建系统需要合并来自以下源集的代码、设置和资源：</p>
<ul>
<li><code>src/baiduDebug/</code>（构建变种源集）</li>
<li><code>src/debug/</code>（构建类型buildType源集）</li>
<li><code>src/baidu/</code>（productFlavor源集）</li>
<li><code>src/main/</code>（main源集）</li>
</ul>
<blockquote>
<p>注意：当你在Android Studio中创建一个新的文件或者目录时，使用File-&gt;New菜单项，你可以为一个具体的源集创建它。你可以选择的这些源集是基于你的构建配置的，并且Android Studio自动创建需要的目录，如果它们不存在的话。</p>
</blockquote>
<p><strong>源集的优先级</strong><br>
如果不同的源集包含同一个文件的不同版本，当决定哪个文件使用的时候Gradle使用下面的优先级顺序。（在左边的源集会重写右边的源集文件和设置）：</p>
<pre><code class="language-java">buildVariant &gt; buildType &gt; productFlavor &gt; main source set &gt; library dependencies
</code></pre>
<p>这可以让Gradle在构建的时候使用与具体构建变种相关的文件，当重用activity，应用逻辑，以及和其他版本通用的资源的时候。当<a href="https://developer.android.com/studio/build/manifest-merge.html">merging multiple manifests</a>的时候，Gradle使用同样的优先级顺序，因此每个构建变种可以定义不同的组件或者权限在最终的manifest文件中。<br>
学习更多关于创建自定义源集，点击<a href="https://developer.android.com/studio/build/build-variants.html">Create source sets for build variants</a>。</p>
<hr>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/89e5b0f3521e">【译】Android构建配置</a><br>
<a href="https://www.jianshu.com/p/e1efbade5d93">Android 多渠道打包配置</a><br>
<strong><a href="https://www.jianshu.com/p/a8870dccda1f">Android Studio Set of source 代码源集</a>  源集创建等操作</strong><br>
<strong><a href="https://developer.android.google.cn/studio/build/build-variants">官方文档</a></strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（三）区间 Range]]></title>
        <id>https://iflytek-duan.github.io/post/kotlinsan-qu-jian-range/</id>
        <link href="https://iflytek-duan.github.io/post/kotlinsan-qu-jian-range/">
        </link>
        <updated>2020-04-20T08:03:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>区间在Java中是没有这个概念的，它在Kotlin中是特有的。</p>
</blockquote>
<h2 id="一-区间的创建">一、区间的创建</h2>
<ul>
<li>
<p><strong>什么是区间</strong><br>
区间是数学上的一个表示范围的概念。</p>
</li>
<li>
<p><strong>区间的类型</strong></p>
<ul>
<li>
<p>闭区间<br>
闭区间是指包含起止值的区间。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ≤ x ≤ b 的实数 x 的集合,<br>
表示为 [ a,b ],叫做闭区间</em></p>
</li>
<li>
<p>开区间<br>
开区间是指不包含起止值的区间。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ＜ x ＜b 的实数 x 的集合,<br>
表示为 ( a,b ),叫做开区间</em></p>
</li>
<li>
<p>半开区间<br>
半开区间是指包含起始值或终止值得区间（也叫前半开区间、后半开区）。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ≤ x ＜b,a ＜x ≤ b 的实数 x 的集合,<br>
分别表示为 [ a,b ),( a,b ],叫做半开区间</em></p>
</li>
<li>
<p>倒序区间<br>
区间的值由大到小排列。</p>
</li>
</ul>
</li>
<li>
<p><strong>区间如何创建</strong></p>
<ul>
<li>创建闭区间<pre><code class="language-kotlin">val intRange = 1..10 // [1,10]
val charRange = 'a'..'z' // [a,z]
val longRange = 1L..100L // [1L,100L]
</code></pre>
</li>
<li>创建开区间（半开区间）<pre><code class="language-kotlin">// 前闭后开区间，不包含结束值
val intRangeExclusive = 1 until 10 // [1,10)
val charRangeExclusive = 'a' until 'z' // [a,z)
val longRangeExclusive = 1L until 100L // [1L,100L)
</code></pre>
</li>
<li>创建倒序区间<pre><code class="language-kotlin">// 区间值由大到小
val intRangeReverse = 10 downTo 1 // [10,9...,1]
val charRangeReverse = 'z' downTo 'a' // [z,a]
val longRangeReverse = 100L downTo 1L // [100L,1L]
</code></pre>
</li>
<li>区间值的打印<br>
通过<code>println(range.joinToString())</code>方法打印即可。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二-区间的步长">二、区间的步长</h2>
<blockquote>
<p>在创建区间时，有时候我们希望区间值之间以固定的间隔进行跳跃，例如原先排列为1，2，3，4，...，10的区间想变成1,3,5,7,...,9的区间，这个时候我们可以通过设置区间的步长（即两两之间的间隔）来达到预期。</p>
</blockquote>
<pre><code class="language-kotlin">// 区间步长的使用
val intRangeWithStep = 1...10 step 2 // [1,3,5,...,9]
val charRangeWithStep = 'a'...'z' step 2 // [a,c,e,...,y]
val longRangeWithStep = 1L...100L step 2 // [1L,3L,...,99L]
</code></pre>
<hr>
<h2 id="三-区间的迭代">三、区间的迭代</h2>
<blockquote>
<p>区间的迭代方式类似于数组的迭代方式。</p>
</blockquote>
<pre><code class="language-kotlin">for(element in intRange){
    println(element)
}

intRange.foreach{
    println(it)
}
</code></pre>
<hr>
<h2 id="四-区间的包含关系">四、区间的包含关系</h2>
<pre><code class="language-kotlin">if(3 in intRage){
    println(&quot;3 in range 'intRange'&quot;)
}

if(12 !in intRange){
    println(&quot;12 not in range 'intRange'&quot;)
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（二）数组Array]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/">
        </link>
        <updated>2020-04-20T03:10:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-kotlin-java中的数组对比">一、Kotlin、Java中的数组对比</h2>
<table>
    <tr>
        <th>数组分类</th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>IntArray</th>
        <th>int[]</th>
    </tr>
    <tr>
        <th>整型装箱</th>
        <th>Array&lt;Int&gt;</th>
        <th>Integer[]</th>
    </tr>
    <tr>
        <th>字符</th>
        <th>CharArray</th>
        <th>char[]</th>
    </tr>
    <tr>
        <th>字符装箱</th>
        <th>Array&lt;Char&gt;</th>
        <th>Character[]</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>Array<String></th>
        <th>String[]</th>
    </tr>
    <tr>
        <th>浮点型</th>
        <th>FloatArray</th>
        <th>float[]</th>
    </tr>
    <tr>
        <th>浮点型装箱</th>
        <th>Array&lt;Float&gt;</th>
        <th>Float[]</th>
    </tr>
    <tr>
        <th>双精度</th>
        <th>DoubleArray</th>
        <th>double[]</th>
    </tr>
    <tr>
        <th>双精度装箱</th>
        <th>Array&lt;Double&gt;</th>
        <th>Double[]</th>
    </tr>
</table>
<hr>
<h2 id="二-数组的创建">二、数组的创建</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] c = new int[]{1,2,3,4,5};
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val k0 = intArrayOf(1,2,3,4,5) // 变长参数
val k1 = IntArray(5){ it + 1 }// kotlin中新建一个对象不需要new关键字，参数一：数 组长度；参数二：lamda表达式，it的值为数组下标。

println(k0.contentToString())
println(k1.contentToString())
</code></pre>
</li>
</ul>
<hr>
<h2 id="三-数组的长度">三、数组的长度</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] array = new int[5];
System.out.println(array.length);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val array = IntArray(5)
println(array.size)
</code></pre>
</li>
</ul>
<hr>
<h2 id="四-数组的读写">四、数组的读写</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">String[] str = new String[]{&quot;Hello&quot;,&quot;World&quot;};
str[1] = &quot;Java&quot;;
System.out.println(str[0] + &quot;, &quot; + str[1]);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val str = arrayOf(&quot;Hello&quot;,&quot;World&quot;)
str[1] = &quot;Kotlin&quot;
println(&quot;${str[0]}, ${str[1]}&quot;)// 使用字符串模板打印
</code></pre>
</li>
</ul>
<hr>
<h2 id="五-数组的遍历">五、数组的遍历</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">float[] floats = new float[]{1,3,5,7};
for(float element : floats){
    System.out.println(element);
}

for(int i=0;i&lt;floats.length;i++){
    System.out.println(floats[i]);
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val floatArray = floatArrayOf(1f,3f,5f,7f)
for(element in floatArray){
    println(element)
}

// 或者使用以下方式遍历
floatArray.foreach{ element -&gt;
  println(element)
}

// 或者下面的方式（对标java中的 for(int i=0;i&lt;floats.length;i++)遍历方式）
for(i in floats.indices){
    println(floats[i])
}
</code></pre>
</li>
</ul>
<hr>
<h2 id="六-判断数组中是否包含某个元素数组的包含关系">六、判断数组中是否包含某个元素（数组的包含关系）</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">int[] intArray = new int[]{1,2,3,4,5};
for(int i : intArray){
    if(i == 4){
        System.out.println(&quot;4 exists in variable 'intArray'&quot;);
    }
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val intArray = IntArray(5){ it +1 }
if(4 in intArray){
    println(&quot;4 exists in variable 'intArray'&quot;)
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（一）基本类型]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-ji-ben-shu-ju-lei-xing/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-ji-ben-shu-ju-lei-xing/">
        </link>
        <updated>2020-04-15T07:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>一、<code>Kotlin</code>、<code>Java</code>基本类型参照表</p>
<table>
    <tr>
        <th></th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>字节</th>
        <th>Byte</th>
        <th>byte/Byte</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>Int & Long</th>
        <th>int/integer & long/Long</th>
    </tr>
    <tr>
        <th>浮点型</th>
        <th>Float & Double</th>
        <th>float/Float & double/Double</th>
    </tr>
    <tr>
        <th>字符</th>
        <th>Char</th>
        <th>char/Char</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>String</th>
        <th>String</th>
    </tr>
</table>
<hr>
<p>二、声明变量</p>
<ul>
<li>
<p>只读变量（不可重新赋值）<br>
通过<code>val</code>修饰符声明，我们可以认为它是<strong>java中带了<code>final</code>修饰符的变量</strong>。</p>
<p>声明变量格式：修饰符 变量名: 类型 = 初始赋值<br>
示例：<br>
<code>val b: String = &quot;Hello Kotlin&quot;</code></p>
</li>
<li>
<p>可读写变量（可重新赋值）<br>
通过<code>var</code>修饰符声明。</p>
</li>
<li>
<p><code>Kotlin</code>支持自动类型推导<br>
<code>kotlin</code>支持自动类型的推导，可以到达简化代码的作用。<br>
如：<code>val b: String = &quot;Hello Kotlin&quot;</code>可以直接写成<code>val b = &quot;Hello Kotlin&quot;</code>。</p>
</li>
<li>
<p><code>Kotlin</code>与<code>Java</code>声明变量对比<br>
<code>Kotlin</code>声明变量：</p>
<pre><code class="language-kotlin">var a: Int = 2
val b: String = &quot;Hello Kotlin&quot;
</code></pre>
<p><code>Java</code>声明变量：</p>
<pre><code class="language-java">int a = 2;
final String b = &quot;Hello Java&quot;;
</code></pre>
</li>
</ul>
<hr>
<p>三、易混淆的Long类型标记<br>
在<code>Java</code>里，开发者在代码中通过以下方式进行<code>Long</code>类型的声明：</p>
<pre><code class="language-java">   long a = 12345678910l;// 小写易混淆
   long b = 12345678910L;// 大写方便识别
</code></pre>
<p>在<code>Kotlin</code>中，声明<code>Long</code>类型变量时，<strong>不支持小写L进行类型声明</strong>，否则编译器会报错</p>
<pre><code class="language-kotlin">   val c = 12345678910L
</code></pre>
<hr>
<p>四、<code>Kotlin</code>的数值类型转换<br>
在<code>Java</code>中，我们可以通过<strong>隐式转换</strong>的方式进行数值类型的转换，示例如下：</p>
<pre><code class="language-java">    int e = 10;
    long f = e;// implicit conversion
</code></pre>
<p>在<code>Kotlin</code>中，这种行为是不被允许的，这也是争议比较大的一点（支持者认为隐式转换安全性存在问题，反对者认为去除隐式转换给开发者带来一些开发过程中的麻烦），示例代码如下：</p>
<pre><code class="language-kotlin">    val e: Int = 10
    val f: Long = e.toLong()
</code></pre>
<hr>
<p>五、无符号类型（v1.3）<br>
<code>Kotlin</code>在兼容<code>C</code>时，创造了与之对应的无符号类型，具体如下：</p>
<table>
    <tr>
        <th></th>
        <th>有符号类型</th>
        <th>无符号类型</th>
    </tr>
    <tr>
        <th>字节</th>
        <th>Byte</th>
        <th>UByte</th>
    </tr>
    <tr>
        <th>短整型</th>
        <th>Short</th>
        <th>UShort</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>Int</th>
        <th>UInt</th>
    </tr>
    <tr>
        <th>长整型</th>
        <th>Long</th>
        <th>ULong</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>String</th>
        <th>String</th>
    </tr>
</table>
<p>无符号类型声明变量示例:</p>
<pre><code class="language-kotlin">    val ua: UInt = 10u
    val ub: ULong = 12345678910u
    val uc: UByte = 1u
</code></pre>
<hr>
<p>六、<code>Kotlin</code>中的变量值比较<br>
<code>kotlin</code>中的值比较通过<code>==</code>操作符来进行，这个有异于<code>Java</code>（<code>Java</code>中是通过<code>equals</code>方法进行值比较，<code>==</code>比较的是变量引用）。</p>
<p>示例：</p>
<pre><code class="language-kotlin">    val k = &quot;Hello Kotlin&quot;
    val m = String(&quot;Hello Kotlin&quot;.toCharArray())

    println(k === m) // compare references-比较引用
    println(k==m) // compare values-比较值
</code></pre>
<p>而<code>Java</code>中则是以下形式：</p>
<pre><code class="language-java">    String k = &quot;Hello Kotlin&quot;;
    String m = new String(&quot;Hello Kotlin&quot;);

    System.out.println(k==m);// compare references-比较引用
    System.out.println(k.equals(m));// compare values-比较值
</code></pre>
<hr>
<p>七、<code>Kotlin</code>中的字符串</p>
<ul>
<li>字符串比较
<ul>
<li>a == b ：比较内容，等价于<code>Java</code>的<code>equals</code>。</li>
<li>a === b ：比较对象是否是<strong>同一个对象</strong>。</li>
</ul>
</li>
<li>字符串模板
<ul>
<li>“Hello，$name”=&gt;&quot;Hello，小明&quot;</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】AndroidStudio升级3.6后如何进入xml布局文件代码编辑页面]]></title>
        <id>https://iflytek-duan.github.io/post/android-androidstudio-sheng-ji-36-hou-ru-he-jin-ru-xml-bu-ju-wen-jian-dai-ma-bian-ji-ye-mian/</id>
        <link href="https://iflytek-duan.github.io/post/android-androidstudio-sheng-ji-36-hou-ru-he-jin-ru-xml-bu-ju-wen-jian-dai-ma-bian-ji-ye-mian/">
        </link>
        <updated>2020-03-04T01:38:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="androidstudio升级36版本前的xml布局文件代码边界页面的进入方式">AndroidStudio升级3.6版本前的xml布局文件代码边界页面的进入方式</h2>
<figure data-type="image" tabindex="1"><img src="https://iflytek-duan.github.io//post-images/1583285974553.png" alt="3.6之前" loading="lazy"></figure>
<h2 id="升级36版本之后的xml预览界面左下角的designtext切换按钮找不到了">升级3.6版本之后的xml预览界面，左下角的Design/Text切换按钮找不到了</h2>
<figure data-type="image" tabindex="2"><img src="https://iflytek-duan.github.io//post-images/1583286117122.png" alt="3.6版本的预览界面" loading="lazy"></figure>
<h2 id="如何进入代码编辑界面点击右上角的图标切换进入即可详情如下图">如何进入代码编辑界面（点击右上角的图标切换进入即可），详情如下图</h2>
<figure data-type="image" tabindex="3"><img src="https://iflytek-duan.github.io//post-images/1583286340534.png" alt="解决方式" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】4G网络状态下访问ipv6反应慢的解决方案]]></title>
        <id>https://iflytek-duan.github.io/post/android-4g-wang-luo-zhuang-tai-xia-fang-wen-ipv6-fan-ying-man-de-jie-jue-fang-an/</id>
        <link href="https://iflytek-duan.github.io/post/android-4g-wang-luo-zhuang-tai-xia-fang-wen-ipv6-fan-ying-man-de-jie-jue-fang-an/">
        </link>
        <updated>2020-02-27T07:21:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>本文转自<strong>feshfans</strong>的博客 <a href="https://www.cnblogs.com/feshfans/p/10269629.html">Android 在 4G 下访问 IPV6 慢的解决方案</a>，仅用于记录解决方式，如有侵权，烦请告知。</p>
<hr>
<h1 id="起因">起因</h1>
<p>因公司iOS上架应用必须要使用ipv6协议，服务端这边新增了ipv6协议支持。<br>
Android刚开始在wifi网络环境下访问一切正常，后来在切换到4G网络状态下时，发下每次请求的时间相对之前都延长了好多，经过搜索参阅上文后，发现是每次解析都会收到两个ip地址（ipv6、ipv4），ipv6总是排在前面，会被优先使用ipv6地址访问解析，所以决定采用文中方案，使用自定义DNS方式将ipv4优先级放在第一位，杜绝此类问题的发生。</p>
<figure data-type="image" tabindex="1"><img src="https://iflytek-duan.github.io//post-images/1582788616554.png" alt="这里盗用一下排查图" loading="lazy"></figure>
<hr>
<h1 id="验证方式">验证方式</h1>
<p>使用下面的代码，验证DNS解析到的IP地址：</p>
<pre><code class="language-java">try {
    InetAddress[] inetAddresses = InetAddress.getAllByName(&quot;server.xxxx.cn&quot;);
    for (InetAddress inetAddress : inetAddresses) {
        Log.d(TAG, inetAddress.getHostAddress());
    }
} catch (UnknownHostException e) {
    e.printStackTrace();
}
</code></pre>
<hr>
<h1 id="解决方案">解决方案</h1>
<p>通过上面的验证，基本断定为 4G 网络下，Android 端通过 ipv6 连接的服务地址。客户端的Retrofit是基于okHttp3为核心实现的网络请求 ，在查看 javadoc 后，发现其提供了 DNS 接口，代码如下：</p>
<pre><code class="language-java">/**
 * A domain name service that resolves IP addresses for host names. Most applications will use the
 * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
 * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
 * addresses, or to force a specific known IP address.
 *
 * &lt;p&gt;Implementations of this interface must be safe for concurrent use.
 */
public interface Dns {
  /**
   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
   */
  Dns SYSTEM = hostname -&gt; {
    if (hostname == null) throw new UnknownHostException(&quot;hostname == null&quot;);
    try {
      return Arrays.asList(InetAddress.getAllByName(hostname));
    } catch (NullPointerException e) {
      UnknownHostException unknownHostException =
          new UnknownHostException(&quot;Broken system behaviour for dns lookup of &quot; + hostname);
      unknownHostException.initCause(e);
      throw unknownHostException;
    }
  };

  /**
   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
   * a connection to an address fails, OkHttp will retry the connection with the next address until
   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
   */
  List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException;
}
</code></pre>
<p>下面我们通过实现此接口，将解析到的 ip 顺序调整一下，如果是 ipv4 则将其放到数据的第一个，其它保持不变，如下图：</p>
<pre><code class="language-java">package com.dohenes.common.data.remote;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;

import okhttp3.Dns;
import retrofit2.internal.EverythingIsNonNull;

/**
 * ClassName Ipv4Dns
 * Describe TODO&lt;ipv4访问优先的DNS--解决ipv6环境下，4G网络访问太慢的问题&gt;
 * Author zihao
 * Date 2020/2/27 14:59
 * Version v1.0
 */
@EverythingIsNonNull
public class Ipv4PriorityDns implements Dns {

    @Override
    public List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException {
        try {
            // 获取指定主机-hostname的IP地址数组（Android解析指定域名获取到的IP）
            List&lt;InetAddress&gt; inetAddressList = new ArrayList&lt;&gt;();
            InetAddress[] inetAddresses = InetAddress.getAllByName(hostname);

            // 遍历获取到的地址，并将得到的ip顺序调整一下，使ipv4放在第一位（即优先使用ipv4协议访问）
            for (InetAddress inetAddress : inetAddresses) {
                if (inetAddress instanceof Inet4Address) {
                    inetAddressList.add(0, inetAddress);
                } else {
                    inetAddressList.add(inetAddress);
                }
            }

            return inetAddressList;
        } catch (NullPointerException exception) {
            UnknownHostException unknownHostException = new
                    UnknownHostException(&quot;Broken system behavior&quot;);
            unknownHostException.initCause(exception);
            throw unknownHostException;
        }
    }
}
</code></pre>
<p>然后设置Retrofit的OkHttpClient，修改其DNS解析类：</p>
<pre><code class="language-java">OkHttpClient.Builder okHttpClientBuilder = new OkHttpClient.Builder()
okHttpClientBuilder.dns(new MyDns());
OkHttpClient okHttpClient = okHttpClientBuilder.build();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】项目结构的演变之路——单Project、模块化、组件化、插件化]]></title>
        <id>https://iflytek-duan.github.io/post/android/</id>
        <link href="https://iflytek-duan.github.io/post/android/">
        </link>
        <updated>2020-02-25T02:59:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-前言">一、前言</h1>
<p>距2008年9月份Google发布Android 1.0操作系统至今已12个年头，Android操作系统、应用也在这个历程中逐步改进创新，丰富了用户的各方面体验。<br>
作为一个开发者，在工作过程中最直观的表现就是开发工具的演变（从Eclipse/IDEA更换为Android Studio）和项目结构的演变（单Project、模块化、组件化、插件化）。</p>
<hr>
<h1 id="二-开发工具的演变">二、开发工具的演变</h1>
<hr>
<h1 id="三-项目结构的演变">三、项目结构的演变</h1>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【朱赟的技术管理】32-硅谷人如何做Code Review]]></title>
        <id>https://iflytek-duan.github.io/post/zhu-yun-de-ji-zhu-guan-li-31/</id>
        <link href="https://iflytek-duan.github.io/post/zhu-yun-de-ji-zhu-guan-li-31/">
        </link>
        <updated>2019-12-23T09:14:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Code Review（代码评审）主要在软件开发的过程中，对源代码进行同级评审，其目的是找出并修正开发过程中出现的错误，保证软件质量，提高开发者自身水平。</p>
</blockquote>
<hr>
<h1 id="一-code-review的commint与pr">一、Code Review的Commint与PR</h1>
<p>硅谷大部分公司是使用Github企业版来管理自己的代码仓库，Github里的Commit和PR的概念在代码审核中风场重要。</p>
<ol>
<li>
<p><strong>Commit</strong><br>
Commit是指Github上的一次“Commit”行为，这是可以单独保存源代码的最小改动单位。</p>
</li>
<li>
<p><strong>PR</strong><br>
也就是Pull Request，是一次代码提交请求。一个PR可以包含一次Commit，也可以是多个。提交请求后Github会在相关页面上显示这次提交请求的代码和原代码的所有不同之处，这就是本次PR的所有改动。</p>
</li>
</ol>
<p>请求提交后，其它工程师可以在PR页面上提出意见和建议，也可以针对某一些代码的改动进行讨论，也可以给出整体评价。代码的作者也可以回复这些意见和建议，或者按照建议进行改动，新的改动将为本次PR中提交新的Commit（也可以覆盖之前的Commit）。</p>
<p>关于Github和Pull Request，池建强老师之前曾经写过一篇<a href="https://mp.weixin.qq.com/s/Ed_qK-Y8hh1hW_CCs6o7KA"><strong>GitHub 为编程世界带来了什么改变？</strong></a>，这边文章中有着比较详细的描述，大家有兴趣的话可以去阅读学习下。</p>
<hr>
<h1 id="二-关于代码合并规则">二、关于代码合并规则</h1>
<p>一般情况下，所有的PR都必须有至少一个人认可，才能进行合并。如果改动的内容涉及多个项目，则需要每个项目都有相关人员确认才可合并。还有一些特别关键的代码，比如支付相关的，通常也会需要支付组的人确认才行。</p>
<p>在代码合并之前，进行Code Review的工程师们会在Github的相关页上给出各种评论，页面是共享的，这些信息是大家都能看的到的。</p>
<p>有些评论是询问，代码的作者直接回复或解释就行，有些是指出代码的问题，代码作者可能会据此改动，也可能不会同意，那就需要回复评论，阐述观点，你来我往。有时候一个实现细节，讨论的主题可能多达十几条或几十条，最终需要达成一致才能合并。</p>
<hr>
<h1 id="三-帮助别人成长而不是帮他写代码">三、帮助别人成长，而不是帮他写代码</h1>
<p>可能有时候，有的人看到别人代码写的“太烂”，觉得在Github上回复评论效率太低，忍不住冲上去帮他搞定，其实这并不是一个非常合适的做法。</p>
<p>首先，从对方的角度来说，代码写不好，可能是对业务不熟悉，对编程语言不熟悉，也可能是公司整体代码结构的不熟悉。如果你帮他“写”，而不是耐心地指出哪里有问题，那么下一次他可能还不知道怎么做。这样不仅无益于别人成长，有时候会让别人有挫败感。</p>
<p>并且，帮别人写代码的方式可拓展性很差。即使Code Review会花掉十倍于你自己写代码的时间和精力，但它会让人明白代码该怎么写，从长远来看，这其实是在一定程度上“复制”了你的生产力赋能给被帮助的人。</p>
<p>作为一个工程师或者管理者，你不能什么都要自己写，尤其是作为一个带项目、新人的管理者，每天Code Review多个人的代码和写多个人的代码，长期而言哪个更划算呢？答案显然是前者更加划算、更具拓展性。</p>
<p>写代码是一个学习的过程，怎么做一个好的代码审核人更是一个学习和成长的过程。自己绕过一个坑不难，难的是看到别人那么走，远远的你就能告诉他那里有个坑，而他在你的指导下成长，以后也会帮助其它人支出类似的问题。</p>
<hr>
<h1 id="四-提交代码的类型">四、提交代码的类型</h1>
<p>在进行Code Review之前，要搞清楚提交的代码到底是干什么的，然后针对性的进行审核。我们一般把代码分为四类：</p>
<ol>
<li><strong>Bug修复</strong><br>
一般公司都有独立的Bug追踪和管理体系，每个Bug都有一个票据（标识）。代码提交的PR，一般是和票据有关的。</li>
<li><strong>代码优化</strong><br>
比如文件的移动和拆分、部分函数的重构、部分计算方式的修改等。</li>
<li><strong>系统迁移</strong><br>
包括代码库的拆分、用另外一种语言编程等。</li>
<li><strong>新系统和新功能</strong><br>
新功能在实现之前都要进行设计审核，最终版本的设计文档会包括数据库的Schema、API的签名（Signature）、代码的流程和模块等内容；相关代码的提交，也就是PR，一般是和设计文档挂钩的。</li>
</ol>
<p>了解了提交代码的作用，审核就会更有针对性和效率，也更容易从作者的角度阅读代码。</p>
<hr>
<h1 id="五-code-review的注意事项">五、Code Review的注意事项</h1>
<h2 id="从代码提交者的角度在代码审核中需要注意哪些问题呢">从代码提交者的角度，在代码审核中需要注意哪些问题呢？</h2>
<ol>
<li>
<p><strong>为什么要进行PR？</strong><br>
原因一定要在提交的时候写得非常清楚，才能帮助审核者理解这次改动是不是合理。上面说的四种提交代码的类型，具体是哪一种，应该写到PR的小结中，写的越详细越好。</p>
<p>这在以后需要进行回溯或追踪系统变化时，也是很有益的。如果改的是前端代码，最好贴一个改动前和改动后的截屏，让改动效果一目了然。</p>
</li>
<li>
<p><strong>除非是极其明显的单词拼写问题，尽量不要引入不是这个PR目的的改动。</strong><br>
PR要尽可能保持目标的单一性。每次遇到有人把一些代码结构的优化合并到功能相关的改动时，都会让人有一种肝火上升的感觉。</p>
<p>这种行为不仅会增加审核者的困难，降低效率，还会掩盖一些简单的错误。并且，如果因为功能的修改导致线上出了问题，一般需要退回到之前的版本，也就是反转PR，这时候，针对优化相关的改动也就必须被反转。总之是弊远远大于利的。</p>
</li>
<li>
<p><strong>找谁审核？</strong><br>
除了本组的人外，有时候代码还会和其他项目组的代码相关，需要找该组的成员审核，这时具体找谁呢？</p>
<p>一般有两个机制来解决这种问题。一是在Github中@一个组，比如Payment组，Risk组等，这些组会通知组里的所有人，相关人看到了就会回去审核；二是有一些组的代码，不希望其他组的人在自己不知道的情况下进行改动，就会设置规则，如果有人动了这些代码，也会通知到整个组。</p>
<p>最后，也是最重要的，一定确保所有的改动都是测试过的，无一例外。</p>
</li>
</ol>
<h2 id="从代码审核者的角度又需要注意哪些问题呢">从代码审核者的角度，又需要注意哪些问题呢？</h2>
<p>审核的粒度要多细？是不是每次审核都要花费很多时间？当然，如果时间足够，自然是看得越细越好。如果特别忙的时候，可以做一些筛选。</p>
<p>比如，你可以看一下算法或编程思路，然后加一个评论“算法部分看起来没有问题”；也可以只看你关心的部分，然后加评论“支付部分没问题”，或者“API部分没问题”。还可以再@一些你觉得可以对其他部分追加评论的人。</p>
<p>另外，如果新人的代码，尽可能的在风格、性能方面都加以审核。如果是一个老员工，这些方面可以给予更多的信任。</p>
<p>具体哪些方面需要审核呢？总结一下大概有以下几点：</p>
<ol>
<li>
<p><strong>代码格式</strong><br>
很多公司研发部都有相关编程风格指南（Code Style Guideline），这是大家约定俗成，避免公司代码风格不一致，也避免了一些“要不要把闭括号另起一行”的无谓争论。老员工除非不小心，通常大家不会弄错；新员工在这方面不太熟悉，就有可能出问题。这一类问题比较容易指出的。</p>
</li>
<li>
<p><strong>代码可读性</strong><br>
比如函数不要太长，太长就进行拆分。所有的变量要能说明它的用意和类型（比如hosting_address_hash，一看久知道是房东地址，而且是个哈希类型）。</p>
<p>不要有太多层的条件语句或者循环语句。不要有一个太长的布尔类型（Boolean）判断语句。如果一个函数别人需要看你的长篇注释才能明白，那这个函数就一定有重构的空间。另外，如果不可避免有一些注释，则一定要保证注释准确且与代码完全一致。</p>
</li>
<li>
<p><strong>业务边界和逻辑死角</strong><br>
你可以帮代码作者想想，他有没有遗漏掉任何业务边界和逻辑死角问题。很多时候这是业务逻辑相关的，尤其需要资深一点的工程师帮助其指出需要处理的所有情况。</p>
</li>
<li>
<p><strong>错误处理（Error Handling）</strong><br>
这是最常见的问题，也是代码审核最容易帮助别人织出来的问题。</p>
</li>
<li>
<p><strong>确保测试用例覆盖到了所有功能路径</strong><br>
严格来说，每段代码都应该有测试用例。如果开发者能够预见到其他人的代码改动会引发自己的代码问题，一定要增加额外的测试用例防止这种情况的发生。</p>
</li>
<li>
<p><strong>代码质量和规范</strong><br>
遵循公司制定的编程规范，比如，有重复的代码段，就应该提取出来公用，不要在代码里随意设置常数，所有的常数都应该有统一的定义，哪些变量应该是私有的，哪些应该是公有的，等等。</p>
</li>
<li>
<p><strong>代码架构</strong><br>
包括代码文件的组织方式，函数是不是抽象到lib或者helper文件里；是不是应该使用继承类；是不是和整个代码库的风格一致；API的定义是不是RESTful的等等。</p>
</li>
</ol>
<hr>
<h1 id="六-公司层面的支持">六、公司层面的支持</h1>
<p>从公司层面应该有哪些措施帮助员工有效的进行代码审核呢？</p>
<ol>
<li>统一的代码提交和审核流程与工具，并确保大家使用同样的工具，遵循相同的流程。</li>
<li>鼓励员工帮助别人审核代码，甚至可以做到绩效评估中。</li>
<li>制定统一的编程规范和代码风格，尤其是有争议的地方，这样可以解决因为一部分人的偏好带来的矛盾。</li>
</ol>
<p>代码审核和编程一样，都是日常工作，不要情绪化。</p>
]]></content>
    </entry>
</feed>