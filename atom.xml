<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iflytek-duan.github.io/</id>
    <title>紫豪的Blog</title>
    <updated>2020-09-29T02:30:29.866Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://iflytek-duan.github.io/"/>
    <link rel="self" href="https://iflytek-duan.github.io/atom.xml"/>
    <subtitle>You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.</subtitle>
    <logo>https://iflytek-duan.github.io/images/avatar.png</logo>
    <icon>https://iflytek-duan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 紫豪的Blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】BLE状态码（status code）参照表]]></title>
        <id>https://iflytek-duan.github.io/post/android-ble-zhuang-tai-ma-status-codecan-zhao-biao/</id>
        <link href="https://iflytek-duan.github.io/post/android-ble-zhuang-tai-ma-status-codecan-zhao-biao/">
        </link>
        <updated>2020-09-23T01:23:57.000Z</updated>
        <content type="html"><![CDATA[<p>成功 / 错误 / 异常对应的状态码：</p>
<table>
    <tr>
        <th>常量名</th>
        <th>16进制Code</th>
        <th>10进制Code</th>
    </tr>
    <tr>
        <th>GATT_SUCCESS</th>
        <th>0x00</th>
        <th>0</th>
    </tr>
    <tr>
        <th>GATT_INVALID_HANDLE</th>
        <th>0x01</th>
        <th>1</th>
    </tr>
    <tr>
        <th>GATT_READ_NOT_PERMIT</th>
        <th>0x02</th>
        <th>2</th>
    </tr>
    <tr>
        <th>GATT_WRITE_NOT_PERMIT</th>
        <th>0x03</th>
        <th>3</th>
    </tr>
    <tr>
        <th>GATT_INVALID_PDU</th>
        <th>0x04</th>
        <th>4</th>
    </tr>
    <tr>
        <th>GATT_INSUF_AUTHENTICATION</th>
        <th>0x05</th>
        <th>5</th>
    </tr>
    <tr>
        <th>GATT_REQ_NOT_SUPPORTED</th>
        <th>0x06</th>
        <th>6</th>
    </tr>
    <tr>
        <th>GATT_INVALID_OFFSET</th>
        <th>0x07</th>
        <th>7</th>
    </tr>
    <tr>
        <th>GATT_INSUF_AUTHORIZATION</th>
        <th>0x08</th>
        <th>8</th>
    </tr>
    <tr>
        <th>GATT_PREPARE_Q_FULL</th>
        <th>0x09</th>
        <th>9</th>
    </tr>
    <tr>
        <th>GATT_NOT_FOUND</th>
        <th>0x0a</th>
        <th>10</th>
    </tr>
    <tr>
        <th>GATT_NOT_LONG</th>
        <th>0x0b</th>
        <th>11</th>
    </tr>
    <tr>
        <th>GATT_INSUF_KEY_SIZE</th>
        <th>0x0c</th>
        <th>12</th>
    </tr>
    <tr>
        <th>GATT_INVALID_ATTR_LEN</th>
        <th>0x0d</th>
        <th>13</th>
    </tr>
    <tr>
        <th>GATT_ERR_UNLIKELY</th>
        <th>0x0e</th>
        <th>14</th>
    </tr>
    <tr>
        <th>GATT_INSUF_ENCRYPTION</th>
        <th>0x0f</th>
        <th>15</th>
    </tr>
    <tr>
        <th>GATT_UNSUPPORT_GRP_TYPE</th>
        <th>0x10</th>
        <th>16</th>
    </tr>
    <tr>
        <th>GATT_INSUF_RESOURCE</th>
        <th>0x11</th>
        <th>17</th>
    </tr>
    <tr>
        <th>GATT_NO_RESOURCES</th>
        <th>0x80</th>
        <th>128</th>
    </tr>
    <tr>
        <th>GATT_INTERNAL_ERROR</th>
        <th>0x81</th>
        <th>129</th>
    </tr>
    <tr>
        <th>GATT_WRONG_STATE</th>
        <th>0x82</th>
        <th>130</th>
    </tr>
    <tr>
        <th>GATT_DB_FULL</th>
        <th>0x83</th>
        <th>131</th>
    </tr>
    <tr>
        <th>GATT_BUSY</th>
        <th>0x84</th>
        <th>132</th>
    </tr>
    <tr>
        <th>GATT_ERROR</th>
        <th>0x85</th>
        <th>133</th>
    </tr>
    <tr>
        <th>GATT_CMD_STARTED</th>
        <th>0x86</th>
        <th>134</th>
    </tr>
    <tr>
        <th>GATT_ILLEGAL_PARAMETER</th>
        <th>0x87</th>
        <th>135</th>
    </tr>
    <tr>
        <th>GATT_PENDING</th>
        <th>0x88</th>
        <th>136</th>
    </tr>
    <tr>
        <th>GATT_AUTH_FAIL</th>
        <th>0x89</th>
        <th>137</th>
    </tr>
    <tr>
        <th>GATT_MORE</th>
        <th>0x8a</th>
        <th>138</th>
    </tr>
    <tr>
        <th>GATT_INVALID_CFG</th>
        <th>0x8b</th>
        <th>139</th>
    </tr>
    <tr>
        <th>GATT_SERVICE_STARTED</th>
        <th>0x8c</th>
        <th>140</th>
    </tr>
    <tr>
        <th>GATT_ENCRYPED_MITM</th>
        <th>GATT_SUCCESS</th>
        <th>0</th>
    </tr>
    <tr>
        <th>GATT_ENCRYPED_NO_MITM</th>
        <th>0x8d</th>
        <th>141</th>
    </tr>
    <tr>
        <th>GATT_NOT_ENCRYPTED</th>
        <th>0x8e</th>
        <th>142</th>
    </tr>
    <tr>
        <th>GATT_CONGESTED</th>
        <th>0x8f</th>
        <th>143</th>
    </tr>
    <tr>
    </tr>
    	 <th colspan="3">/* 0xE0 ~ 0xFC reserved for future use */</th>
    <tr>
        <th>GATT_CCC_CFG_ERR /* Client Characteristic Configuration Descriptor Improperly Configured */</th>
        <th>0xFD</th>
        <th>253</th>
    </tr>
    <tr>
        <th>GATT_PRC_IN_PROGRESS /* Procedure Already in progress */</th>
        <th>0xFE</th>
        <th>254</th>
    </tr>
    <tr>
        <th>GATT_OUT_OF_RANGE /* Attribute value out of range */</th>
        <th>0xFF</th>
        <th>255</th>
    </tr>
</table>
<p>其它状态码参照：<a href="https://blog.csdn.net/zhoubintiantian/article/details/77193705?utm_source=blogxgwz3">Android BLE Gatt返回错误对应宏</a><br>
<a href="https://blog.csdn.net/xuwenwen_2013/article/details/79413559">BLE操作成功或失败status code对应解释</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】自动化打包]]></title>
        <id>https://iflytek-duan.github.io/post/android-zi-dong-hua-da-bao/</id>
        <link href="https://iflytek-duan.github.io/post/android-zi-dong-hua-da-bao/">
        </link>
        <updated>2020-09-16T02:23:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-签名配置signingconfigs">一、签名配置signingConfigs</h1>
<pre><code class="language-java">// 自动化打包配置-签名信息
signingConfigs {
    release {// 线上环境
        keyAlias 'xxx'// key别名，如taibang
        keyPassword 'xxxxxxxx'// key密码
        storeFile file('/xxx.jks')// 密钥文件路径，如/taibang.jsk
        storePassword 'xxxxxxxx'// 密钥文件密码
        v1SigningEnabled true
        v2SigningEnabled true
    }

    debug {// 开发环境
        keyAlias 'xxx'
        keyPassword 'xxxxxxxx'
        storeFile file('/xxx.jks')
        storePassword 'xxxxxxxx'
        v1SigningEnabled true
        v2SigningEnabled true
    }
}
</code></pre>
<hr>
<h1 id="二-产品风味特点的defaultconfig配置">二、产品风味（特点）的DefaultConfig配置</h1>
<pre><code class="language-java">flavorDimensions &quot;channel&quot; // 特点维度，为了让多渠道包间的纬度统一，方便productFlavors维度统一
</code></pre>
<p>关于<code>flavorDimensions</code>的具体解释可参考下文：<br>
<a href="https://www.freesion.com/article/7504275783/">FLAVORDIMENSIONS多维度理解(版本差异化打包)</a></p>
<hr>
<h1 id="三-产品风味特点-多渠道配置productflavors">三、产品风味（特点）/ 多渠道配置productFlavors</h1>
<pre><code class="language-java">// 多渠道信息配置
productFlavors {
    taibang {// 默认就是泰邦健康管家渠道
        dimension &quot;channel&quot;
    }

    qfjp {
        dimension &quot;channel&quot;
    }
}
</code></pre>
<hr>
<p>#四、 统一配置多渠道信息</p>
<pre><code class="language-java">// 统一配置多渠道信息
productFlavors.all { flavor -&gt;
    flavor.manifestPlaceholders = [XXX_CHANNEL: name] // 如BUGLY_APP_CHANNEL
}
</code></pre>
<hr>
<h1 id="五-配置自动构建后的apk文件名称">五、配置自动构建后的apk文件名称</h1>
<pre><code class="language-java">    // 配置构建后apk的文件名称
    applicationVariants.all { variant -&gt;
        variant.outputs.all { output -&gt;
            def buildName = &quot;TaiBang&quot;
            def type = variant.buildType.name
            def releaseApkName
            releaseApkName = buildName + '_' + &quot;${defaultConfig.versionName}&quot; + '_' + type + &quot;_&quot; + &quot;${releaseTime()}&quot; + '.apk'
            outputFileName = releaseApkName
        }
    }
</code></pre>
<p>在<code>app/build.gradle</code>内的<code>android</code>标签外新增<code>releaseTime</code>方法：</p>
<pre><code class="language-java">android {
    ...
}

/**
 * 定义的打包时间
 * @return
 */
static def releaseTime() {
    return new Date().format(&quot;yyyyMMddHHmm&quot;, TimeZone.getTimeZone(&quot;GMT+08:00&quot;))
}
</code></pre>
<hr>
<h1 id="六-构建类型buildtypes配置">六、构建类型buildTypes配置</h1>
<p><code>buildTypes</code>默认有<code>debug</code>、<code>release</code>两个构建类型，可以根据需要新增</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        signingConfig signingConfigs.release
    }

    debug {
        minifyEnabled false
        signingConfig signingConfigs.debug
    }
}

</code></pre>
<hr>
<h1 id="七-自动构建对应渠道类型的apk包">七、自动构建对应渠道/类型的apk包</h1>
<p>点开<code>Android Studio</code>右侧的<code>Gradle</code>工具栏，找到<code>ProjectName-&gt;Tasks-&gt;Build-&gt;assembleDebug/assembleRelease/assembleBuildTypes/assembleProductFlavors</code>即可构建对应渠道/类型下的apk包，输出路径为默认的<code>app/build/outputs/apk/对应路径</code>。</p>
<hr>
<p><a href="https://blog.csdn.net/stimgo/article/details/77480154?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">AndroidStudio多渠道打包，生成不同app</a><br>
<a href="https://blog.csdn.net/yujihu989/article/details/54589684">Android Studio配置Gradle（包括signingConfigs、buildTypes和productFlavors等）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（七）扩展方法]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-qi-kuo-zhan-fang-fa/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-qi-kuo-zhan-fang-fa/">
        </link>
        <updated>2020-09-03T03:30:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-扩展方法的概述">一、<a href="https://www.runoob.com/kotlin/kotlin-extensions.html">扩展方法</a>的概述</h1>
<p><code>Kotlin</code> 可以对一个类的属性和方法进行扩展，且不需要继承或使用<code>Decorator</code>（装饰者）模式。<br>
<strong>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</strong></p>
<blockquote>
<p>例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为 扩展函数 。此外，也有 扩展属性 ， 允许你为一个已经存在的类添加新的属性。</p>
</blockquote>
<h2 id="在java中没有扩展方法这个概念kotlin的扩展方法类似于java中的工具类中的方法">在<code>Java</code>中没有扩展方法这个概念，<code>Kotlin</code>的扩展方法类似于<code>Java</code>中的工具类中的方法。</h2>
<h1 id="二-扩展函数">二、扩展函数</h1>
<p>扩展函数可以在已有类中添加新的方法，不会对原类做修改。</p>
<ul>
<li>
<p><strong>扩展函数定义形式</strong></p>
<pre><code class="language-kotlin">fun receiverType.functionName(params) {
    // body    
}
</code></pre>
<ul>
<li><code>receiverType</code>：表示函数的接收者</li>
<li><code>functionName</code>：扩展函数的名称</li>
<li><code>params</code>：扩展函数的参数，可以为<code>NULL</code></li>
</ul>
</li>
<li>
<p><strong>扩展函数示例</strong></p>
<pre><code class="language-kotlin">class User(var name: String)

// 扩展函数
fun User.printName(){
    println(&quot;用户名 $name&quot;)
}

fun main(args: Array&lt;String&gt;) {
    var user = User(&quot;Robin&quot;)
    user.printName();
}
</code></pre>
</li>
</ul>
<hr>
<h1 id="三-扩展函数是静态解析的">三、扩展函数是静态解析的</h1>
<p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的，具体示例如下：</p>
<pre><code class="language-kotlin">open class SimpleClass
class SubClass: SimpleClass

fun SimpleClass.foo() = &quot;ABC&quot;// 扩展函数 foo
fun SubCLass.f00() = &quot;DEF&quot;

func printFoo(c: SimpleClass) {
    println(c.foo())
}

fun main(args: Array&lt;String&gt;) {
    printlnFoo(SubClass())
}
</code></pre>
<p>输出结果为：<br>
<code>ABC</code></p>
<p><strong>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</strong></p>
<pre><code class="language-kotlin">class SimpleClass {
    fun foo() {
        println(&quot;成员函数&quot;)
    }
}

fun SimpleClass.foo() {
    println(&quot;扩展函数&quot;)
}

fun main(args: Array&lt;String&gt;) {
    var c = SimpleClass()
    c.foo()
}
</code></pre>
<p>实际输出结果为：<br>
<code>成员函数</code></p>
<hr>
<h1 id="四-扩展一个空对象">四、扩展一个空对象</h1>
<p>在扩展函数内，可以通过<code>this</code>来判断接收者是否为<code>NULL</code>，即使接收者为<code>NULL</code>，也可以调用扩展函数，如：</p>
<pre><code class="language-kotlin">fun Any?.toString(): String {
    if (this == null) return &quot;null&quot;
    // 空检测之后，&quot;this&quot;会自动转换为非空类型，所以下面的toString()解析为Any类的成员函数
    return toString()
}

fun main(args: Array&lt;String&gt;) {
    var t = null
    println(t.toString())
}
</code></pre>
<p>实际输出结果为：<br>
<code>null</code></p>
<hr>
<h1 id="五-扩展属性">五、扩展属性</h1>
<p>除了函数，<code>Kotlin</code>也支持对属性进行扩展：</p>
<pre><code class="language-kotlin">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
    get() = size - 1
</code></pre>
<p>扩展属性允许定义在类或者<code>Kotlin</code>文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（back field），所以不允许被初始化，只能由显式的<code>getter/setter</code>定义。</p>
<pre><code class="language-kotlin">val Foo.bar = 1 // 错误：扩展属性不能有初始化器
</code></pre>
<hr>
<h1 id="六-伴生对象的扩展">六、伴生对象的扩展</h1>
<p>如果一个类定义有一个<a href="https://www.runoob.com/kotlin/kotlin-object-declarations.html">伴生对象</a>，你也可以为伴生对象定义扩展函数和属性。<br>
伴生对象通过“类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p>
<pre><code class="language-kotlin">class MyClass {
    companion object { } //将被称为companion
}

fun MyClass.Companion.foo() {
    println(&quot;伴生对象的扩展函数&quot;)
}

val MyClass.Companion.no: Int
    get() = 10

fun main(args: Array&lt;String&gt;) {
    println(&quot;no:${MyClass.no}&quot;)
    MyClass.foo()
}
</code></pre>
<p>实力执行后输出结果为：</p>
<pre><code class="language-kotlin">no:10
伴生对象的扩展函数
</code></pre>
<hr>
<blockquote>
<p>伴生对象内的成员相当于 Java 中的静态成员，其生命周期伴随类始终，在伴生对象内部可以定义变量和函数，这些变量和函数可以直接用类名引用。</p>
</blockquote>
<p>对于伴生对象扩展函数，有两种形式，一种是在类内扩展，一种是在类外扩展，这两种形式扩展后的函数互不影响（甚至名称都可以相同），即使名称相同，它们也完全是两个不同的函数，并且有以下特点：</p>
<ol>
<li>类内扩展的伴随对象函数和类外扩展的伴随对象可以同名，它们是两个独立的函数，互不影响；</li>
<li>当类内扩展的伴随对象函数和类外扩展的伴随对象同名时，类内的其它函数优先引用类内扩展的伴随对象函数，即对于类内其它成员函数来说，类内扩展屏蔽类外扩展；</li>
<li>类内扩展的伴随对象函数只能被类内的函数引用，不能被类外的函数和伴随对象内的函数引用；</li>
<li>类外扩展的伴随对象函数可以被伴随对象内的函数引用<br>
例如以下代码：</li>
</ol>
<pre><code class="language-kotlin">class MyClass {
    companion object {
        val myClassField1: Int = 1
        var myClassField2 = &quot;this is myClassField2&quot;
        fun companionFun1() {
            println(&quot;this is 1st companion function.&quot;)
            foo()
        }
        fun companionFun2() {
            println(&quot;this is 2st companion function.&quot;)
            companionFun1()
        }
    }
    fun MyClass.Companion.foo() {
        println(&quot;伴随对象的扩展函数（内部）&quot;)
    }
    fun test2() {
        MyClass.foo()
    }
    init {
        test2()
    }
}
val MyClass.Companion.no: Int
    get() = 10
fun MyClass.Companion.foo() {
    println(&quot;foo 伴随对象外部扩展函数&quot;)
}
fun main(args: Array&lt;String&gt;) {
    println(&quot;no:${MyClass.no}&quot;)
    println(&quot;field1:${MyClass.myClassField1}&quot;)
    println(&quot;field2:${MyClass.myClassField2}&quot;)
    MyClass.foo()
    MyClass.companionFun2()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-kotlin">no:10
field1:1
field2:this is myClassField2
foo 伴随对象外部扩展函数
this is 2st companion function.
this is 1st companion function.
foo 伴随对象外部扩展函数
</code></pre>
<hr>
<h1 id="七-扩展的作用域">七、扩展的作用域</h1>
<p>通常扩展函数或属性定义在顶级包下：</p>
<pre><code class="language-kotlin">package foo.bar

fun Baz.goo() {...}
</code></pre>
<p>要使用所定义包之外的一个扩展，通过import到入扩展函数名进行使用：</p>
<pre><code class="language-kotlin">package com.example.usage

import foo.bar.goo // 导入所有名为goo的扩展
// 或者从foo.bar导入一切
import foo.bar.*

fun usage(baz: Baz) {
    baz.goo()
}
</code></pre>
<hr>
<h1 id="八-扩展声明为成员">八、扩展声明为成员</h1>
<p>在一个类内部你可以为另一个类声明扩展。<br>
在这个扩展中，有多个隐含的接收者，其中扩展方法定义所在类的实例成为分发接收者，而扩展方法的目标类型的实例成为扩展接收者。</p>
<pre><code class="language-kotlin">class D {
    fun bar () { println(&quot;D bar&quot;) }
}

class C {
    fun baz() { println(&quot;C baz&quot;) }

    fun D.foo() {
        bar () // 调用D.bar
        baz () // 调用C.baz
    }

    fun caller(d: D) {
        d.foo() // 调用扩展函数
    }
}

fun main(args: Array&lt;String&gt;) {
    val c: C = C()
    val d: D = D()
    c.caller(d)
}
</code></pre>
<p>实力输出结果为:</p>
<pre><code class="language-kotlin">D bar
C baz
</code></pre>
<p>在C类中，创建了D类的扩展。此时，C被称为分发接收者，而D为扩展接收者。<br>
从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。<br>
假如在调用某一个函数，而该函数在分发接收者和扩展接收者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的<code>this</code>语法。</p>
<pre><code class="language-kotlin">class D {
    fun bar () { println(&quot;D bar&quot;) }
}

class C {
    fun bar() { println(&quot;C bar&quot;) } // 与D类的bar同名

    fun D.foo() {
        bar () // 调用D.bar，扩展接收者优先
        this@C.bar () // 调用C.bar
    }

    fun caller(d: D) {
        d.foo() // 调用扩展函数
    }
}

fun main(args: Array&lt;String&gt;) {
    val c: C = C()
    val d: D = D()
    c.caller(d)
}
</code></pre>
<p>实力输出结果为:</p>
<pre><code class="language-kotlin">D bar
C bar
</code></pre>
<p>以成员的形式定义的扩展函数，可以声明为<code>open</code>，而且可以在子类中覆盖，也就是说，在这类扩展函数的派发过程中，针对分发接收者是虚拟的（Virtual），但针对扩展接收者仍然是静态的。</p>
<pre><code class="language-kotlin">open class D {
}

open class D1: D {
}

open class C {
    open fun D.foo() {
        println(&quot;D.foo in C&quot;)
    }

    open fun D1.foo() {
        println(&quot;D1.foo in C&quot;)
    }

    fun caller(d: D) {
        d.foo()
    }
}

class C1: C() {
    override fun D.foo() {
        println(&quot;D.foo in C1&quot;)
    }

    override fun D1.foo() {
        println(&quot;D1.foo in C1&quot;)
    }
}

fun main(args: Array&lt;String&gt;) {
    C().caller(D()) // 输出“D.foo in C”
    C1().caller(D()) // 输出“D.foo in C1”--分发接收者虚拟解析
    C().caller(D1()) // 输出“D.foo in C”--扩展接收者静态解析
}
</code></pre>
<p>实力执行输出结果为：</p>
<pre><code class="language-kotlin">D.foo in C
D.foo in C1
D.foo in C
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（六）类和接口]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-lei-he-jie-kou/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-lei-he-jie-kou/">
        </link>
        <updated>2020-09-02T07:15:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-类的定义">一、类的定义</h1>
<ul>
<li>
<p><strong>java中定义类</strong></p>
<pre><code class="language-java">public class SimpleClass {
    // 定义成员变量
    public int x;

    // 定义构造方法
    public SimpleClass(int x) {
        this.x = x;
    }

    // 定义方法
    public void y() {
    }
}
</code></pre>
</li>
<li>
<p><strong>kotlin中定义类</strong></p>
<ul>
<li>
<p><strong>副构造器写法</strong></p>
<pre><code class="language-kotlin">class SimpleClass {// Kotlin中的类默认都是public
    // 定义成员变量，Kotlin中必须初始化
    var x: Int = 0

    // 定义构造方法，对应Kotlin中的副构造器
    constructor(x: Int) {
        this.x = x
    }

    // 定义方法
    fun y() {
    }
}
</code></pre>
</li>
<li>
<p><strong>主构造器写法</strong></p>
<pre><code class="language-kotlin">// 对应Kotlin中的主构造器的概念，主构造器要求其它所有的构造器都要调用它
class SimpleClass
        constructor(x: Int){
            var x: Int = x
}

// 精简写法
class SimpleClass(x: Int){
            var x: Int = x
}

// 精简写法2
class SimpleClass(var x: Int){
}
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-类的实例化">二、类的实例化</h1>
<ul>
<li>
<p><strong>Java中类的实例化</strong></p>
<pre><code class="language-java">SimpleClass simpleClass = new SimpleClass(1)
System.out.println(simpleClass.x);
simpleClass.y();
</code></pre>
</li>
<li>
<p><strong>Kotlin中类的实例化</strong></p>
<pre><code class="language-kotlin">val simpleClass = SimpleClass(2)
println(simpleClass.x)
simpleClass.y()
</code></pre>
</li>
</ul>
<hr>
<h1 id="三-接口的定义">三、接口的定义</h1>
<ul>
<li>
<p><strong>Java中接口的定义</strong></p>
<pre><code class="language-java">public interface SimpleInterface {
    void simpleMethod();
}
</code></pre>
</li>
<li>
<p><strong>Kotlin中接口的定义</strong></p>
<pre><code class="language-kotlin">interface SimpleInterface {
    fun simpleMethod()
}
</code></pre>
</li>
</ul>
<hr>
<h1 id="四-接口的实现">四、接口的实现</h1>
<ul>
<li>
<p><strong>Java中接口的实现</strong></p>
<pre><code class="language-java">public class SimpleClass
        implements SimpleInterface {
            ...
            @Override
            public void simpleMethod(){
            }
}
</code></pre>
</li>
<li>
<p><strong>Kotlin中接口的实现</strong></p>
<pre><code class="language-kotlin">class SimpleClass(var x: Int)
    : SimpleInterface {
        ...
        override fun simpleMethod() {
        }
}
</code></pre>
</li>
</ul>
<blockquote>
<p>注：Java中的<code>Override</code>是<code>jdk 1.5</code>以后引入的一个注解，在<code>Java</code>中它不是强制必须要添加的，在Kotlin中你必须要添加<code>override</code>关键字；<br>
<code>Override</code>表示覆盖，它是一个比较危险的行为——有可能会覆写到别人的方法。</p>
</blockquote>
<hr>
<h1 id="五-抽象类的定义">五、抽象类的定义</h1>
<ul>
<li>
<p><strong>Java中抽象类的定义</strong></p>
<pre><code class="language-java">public abstract class AbsClass {
    // 抽象方法，它是一定用来被覆写的
    public abstract void absMethod();
    // 未添加final关键字的方法默认也是可以被覆写的
    protected void overrideable() { }
    // 添加final关键字的方法不能被覆写
    public final void nonOverrideable() { }
}
</code></pre>
</li>
<li>
<p><strong>Kotlin中抽象类的定义</strong></p>
<pre><code class="language-kotlin">abstract class AbsClass {
    // 抽象方法，它是一定用来被覆写的
    abstract fun absMethod()
    // Kotlin抽象类中的方法默认不可以被覆写，你必须添加open关键字才能够对它进行覆写
    open fun overrideable() { }
    fun nonOverrideable() { }
}
</code></pre>
</li>
</ul>
<blockquote>
<p>注意：<br>
1.<code>Java</code>和<code>Kotlin</code>抽象类中的抽象方法都可以被覆写；<br>
2.<code>Java</code>抽象类中的其它方法默认是可以被覆写的，而<code>Kotlin</code>中则默认不可以被覆写；<br>
3.<code>Java</code>抽象类中在方法前添加<code>final</code>关键字可以保证该方法不能被覆写；<br>
4.<code>Kotlin</code>抽象类中在方法前添加<code>open</code>关键字可以允许该方法能被覆写。</p>
</blockquote>
<hr>
<h1 id="六-类的继承">六、类的继承</h1>
<ul>
<li>
<p><strong>Java中类的继承</strong></p>
<pre><code class="language-java">public class SimpleClass
    extends AbsClass implements SimpleInterface {
        ...
}
</code></pre>
</li>
<li>
<p><strong>Kotlin中类的继承</strong></p>
<pre><code class="language-kotlin">// kotlin在继承类的时候相对实现接口会在类名后多一个()，因为它调用了父类的构造方法
class SimpleClass(var x: Int)
    : AbsClass(), SimpleInterface {
        ...
}
</code></pre>
</li>
</ul>
<hr>
<h1 id="七-属性property">七、属性Property</h1>
<blockquote>
<p><code>Java</code>中没有属性这个概念，而是通过语法约定的形式来实现</p>
</blockquote>
<pre><code class="language-java">public class Person {
    private int age;// field-领域
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>
<p><strong>Kotlin中的属性Property</strong></p>
<pre><code class="language-kotlin">class Person(age: Int) {
    var age: Int = age // Property，它等于Java中的filed+get+set
        get() {
            return filed
        }
        set(value) {
            filed = value
        }
}
</code></pre>
<hr>
<h1 id="八-属性引用">八、属性引用</h1>
<blockquote>
<p>Kotlin中的属性引用类似于函数引用</p>
</blockquote>
<pre><code class="language-kotlin">// 未绑定Receiver
val ageRef = Person::age
val person = Person(18)
ageRef.set(person, 22)

// 绑定Receiver
val ageRef2 = person::age
ageRef2.set(33)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（五）函数]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-wu-han-shu/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-wu-han-shu/">
        </link>
        <updated>2020-08-31T08:54:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-函数的定义">一、函数的定义</h1>
<ul>
<li><strong>格式：</strong><br>
关键字(fun) 函数名(参数列表): 返回值类型{<br>
// 函数体<br>
}</li>
<li><strong>示例：</strong><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;): Unit {// Unit等价于Java中的void，函数返回值为Unit可省略
    println(args.contentToString)
}
</code></pre>
</li>
</ul>
<hr>
<h1 id="二-函数-vs-方法">二、函数 vs 方法</h1>
<ul>
<li><strong>方法可以认为是函数的一种特殊类型</strong></li>
<li><strong>从形式上，有receiver(接收者)的函数即为方法</strong><pre><code class="language-kotlin">    @JvmStatic
    fun main(vararg args: String) {
        val foo: Foo = Foo();
        foo.bar(&quot;helloKotlin&quot;, 0L) // foo就是上文所述的receiver
    }

    class Foo {
        fun bar(p0: String, p1: Long): Any {
            println(&quot;The first param is $p0&quot;)
            return p1
        }
    }
</code></pre>
</li>
</ul>
<p>注：其实所谓的方法就是外面套了一个类，它的receiver就是外面套的类的实例。</p>
<hr>
<h1 id="三-函数的类型">三、函数的类型</h1>
<table>
<tr>
<th>函数</th>
<th>返回值类型</th>
</tr>
<tr>
<th>fun foo(){ }</th>
<th>() -> Unit</th>
</tr>
<tr>
<th>fun foo(p0: Int): String {...}</th>
<th> (Int) -> String</th>
</tr>
<tr>
<th>
class Foo {
    fun bar(p0: String, p1:Long): Any {...}        
}
</th>
<th>Foo.(String, Long) -> Any</th>
</tr>
</table>
<hr>
<h1 id="四-函数的引用">四、函数的引用</h1>
<ul>
<li><strong>函数的引用类似于C语言中的函数指针，可以用于函数传递</strong><pre><code class="language-kotlin">fun foo() {}// 定义函数
::foo// 函数引用
val f: () -&gt; Unit = ::foo// 定义变量接收引用

fun foo(p0: Int): String {...}
::foo
val g: (Int) -&gt; String = ::foo

// 带有receiver的函数引用
class Foo {
    fun bar(p0: String,p1: Long): Any {...}
}
Foo::bar
val h: (Foo, String, Long) -&gt; Any = Foo::bar

val foo = Foo()
val m: (String, Long) -&gt; Any = foo::bar // 绑定receiver的函数引用
</code></pre>
</li>
</ul>
<hr>
<h1 id="五-变长参数">五、变长参数</h1>
<blockquote>
<p>变长参数就是指我们在调用一个函数的时候可以根据情况传入不同数量的参数，个数在调用之前是不确定的，在调用的时候长度、类型都是确定的。</p>
</blockquote>
<ul>
<li>
<p><strong>java中的变长参数:</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
//
}
</code></pre>
</li>
<li>
<p><strong>kotlin中的变长参数：</strong></p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
//
}
</code></pre>
</li>
</ul>
<h1 id="六-多返回值">六、多返回值</h1>
<blockquote>
<p>多返回值返回值的个数是确定的，但是是多个。</p>
</blockquote>
<ul>
<li><strong>kotlin中的多返回值</strong><pre><code class="language-kotlin">fun multiReturnValues(): Triple&lt;Int, Long, Double&gt; {
    return Triple(3, 4L, 5.0);
}

val (a, b, c) = multiReturnValues()
</code></pre>
</li>
</ul>
<hr>
<h1 id="七-默认参数">七、默认参数</h1>
<ul>
<li>
<p><strong>函数的定义：</strong></p>
<pre><code class="language-kotlin">    /**
    * 默认参数
    */
    fun defaultParameter(x: Int, y: String, z: Long = 0L) {
        println(&quot;defaultParameter&quot;)
    }
</code></pre>
</li>
<li>
<p><strong>函数的使用</strong></p>
<pre><code class="language-kotlin">    // 默认参数
    defaultParameter(1, &quot;test&quot;)
</code></pre>
</li>
</ul>
<hr>
<h1 id="八-具名参数">八、具名参数</h1>
<pre><code class="language-kotlin">    /**
     * 默认参数
     */
    fun defaultParameter(x: Int = 5, y: String, z: Long = 0L) {
        println(&quot;defaultParameter&quot;)
    }

    // 具名参数--形参y来显示接收参数
    defaultParameter(y = &quot;HelloX&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】代码混淆]]></title>
        <id>https://iflytek-duan.github.io/post/android-dai-ma-hun-yao/</id>
        <link href="https://iflytek-duan.github.io/post/android-dai-ma-hun-yao/">
        </link>
        <updated>2020-07-01T02:34:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-app混淆配置">一、App混淆配置</h1>
<p><strong>1. 基础的指令配置</strong></p>
<pre><code class="language-java">-optimizationpasses 5 # 指定代码的压缩级别
-dontusemixedcaseclassnames # 混淆后类名都为小写
-dontskipnonpubliclibraryclasses #指定不去忽略非公共的库的类
-dontskipnonpubliclibraryclassmembers #指定不去忽略非公共的库的类的成员
-dontpreverify # 不做预校验的操作
-verbose # 混淆时是否记录日志
-printmapping proguardMapping.txt #生成原类名和混淆后的类名的映射文件
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  # 混淆时所采用的算法
-keepattributes *Annotation*,InnerClasses #不混淆Annotation
-keepattributes Signature #不混淆泛型
-keepattributes SourceFile,LineNumberTable #抛出异常时保留代码行号
-ignorewarnings #抑制警告
</code></pre>
<p><strong>2. 一些通用的必要配置</strong></p>
<pre><code class="language-java">#系统类不需要混淆
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingS
-keep class android.support.** {*;}
-keep public class * extends android.app.Fragment

-keepclasseswithmembernames class * {  # 保持 native 方法不被混淆
    native &lt;methods&gt;;
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆
    public void *(android.view.View);
}
-keepclassmembers enum * {# 保持枚举 enum 类不被混淆
    public static **[] values();
    public static ** valueOf(java.lang.String);
}
-keep public class * extends android.view.View{# 保持View类不被混淆
    *** get*();
    void set*(***);
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclasseswithmembers class * {# 保持自定义控件类不被混淆
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆
    public static final android.os.Parcelable$Creator *;
}
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}
-keep class **.R$* {
 *;
}
-keepclassmembers class * {
    void *(**On*Event);
}

#WebView相关
-keepclassmembers class fqcn.of.javascript.interface.for.Webview {
   public *;
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String);
}

# 其它
-keep class com.google.android.gms.** {*;}
-dontwarn com.google.android.gms.**
-dontwarn com.viewpagerindicator.*
-dontwarn com.amazonaws.**
-dontnote com.google.vending.licensing.ILicensingService
-dontnote com.android.vending.licensing.ILicensingService


# Androidx相关
-keep class com.google.android.material.** {*;}
-keep class androidx.** {*;}
-keep public class * extends androidx.**
-keep interface androidx.** {*;}
-dontwarn com.google.android.material.**
-dontnote com.google.android.material.**
-dontwarn androidx.**
</code></pre>
<p><strong>3. 实体类</strong></p>
<pre><code class="language-java"># 可能会存在多处，需要一一添加
-keep class 包名.bean.** {*;}
</code></pre>
<p><strong>4. 第三方Library</strong></p>
<pre><code class="language-java"># 本地.so库文件声明
-libraryjars libs/armeabi/xxx.so
-libraryjars libs/armeabi-v7/xxx.so
-libraryjars libs/x86/xxx.so

# 常用第三方Library混淆配置
# Glide
-keep public class * implements com.bumptech.glide.module.GlideModule
-keep public class * extends com.bumptech.glide.module.AppGlideModule
-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
  **[] $VALUES;
  public *;
}

# Alipay
-dontwarn com.alipay.**
-dontwarn com.ta.utdid2.**
-dontwarn com.ut.device.**
-dontwarn android.net.**
-keep class com.alipay.** {*;}
-keep class com.ta.utdid2.** {*;}
-keep class com.ut.device.** {*;}
-keep class android.net.SSLCertificateSocketFactory

# butterknife
-keep class butterknife.** {*;}
-dontwarn butterknife.internal.**
-keep class **$$ViewBinder {*;}
-keepclasseswithmembernames class * {
    @butterknife.* &lt;fields&gt;;
}
-keepclasseswithmembernames class * {
    @butterknife.* &lt;methods&gt;;
}

# eventbus
-keepattributes *Annotation*
-keepclassmembers class ** {
    @com.google.common.eventbus.Subscribe &lt;methods&gt;;
        public void onEvent*(**);
        void onEvent*(**);
}
-keep enum de.greenrobot.event.ThreadMode {*;}
-keepclassmembers class * extends de.greenrobot.event.util.ThrowableFailureEvent {
    &lt;init&gt;(java.lang.Throwable);
}

# Gson
-dontwarn com.google.gson.**
-keep class com.google.gson.** {*;}
-keep class sun.misc.Unsafe {*;}

# 科大讯飞相关(ifly_push_sdk &amp;&amp; Msc)
-dontwarn com.iflytek.**
-keep class com.iflytek.** {*;}

# 腾讯相关(libammsdk &amp;&amp; open_sdk)
-dontwarn com.tencent.**
-keep class com.tencent.** {*;}

# weibosdkcore
-dontwarn com.sina.weibo.sdk.**
-keep class com.sina.weibo.sdk.** {*;}

# Dagger
-dontwarn dagger.internal.codegen.**
-dontwarn javax.inject.**
-keepclassmembers,allowobfuscation class * {
    @javax.inject.* *;
    @dagger.* *;
    &lt;init&gt;();
}
-keep class dagger.** {*;}
-keep class javax.inject.** {*;}
-keep class * extends dagger.internal.Binding
-keep class * extends dagger.internal.ModuleAdapter
-keep class * extends dagger.internal.StaticInjection

</code></pre>
<blockquote>
<p>这里要注意的一点是，要避免重复声明jar包——如果在build.gradle中使用了<code>compile fileTree(include: ['*.jar'], dir: 'libs')</code>，就不需要在混淆文件中添加<code>-libraryjars libs/xxx.jar</code>去声明对应的jar了，否则会报错提示重复添加。</p>
</blockquote>
<p><strong>5. 反射类及其相关方法</strong></p>
<pre><code class="language-java">-keep class java.lang.annotation.** {*;}
</code></pre>
<p><strong>6. JS相关交互类(方法互调)</strong></p>
<pre><code class="language-java"></code></pre>
<hr>
<h1 id="二-moduleaar-lib混淆配置">二、Module（aar、lib)混淆配置</h1>
<blockquote>
<p>我们在封装<code>aar、lib</code>提供给他人使用时，为了保证功能能够正常的被使用，往往需要告知别人针对<code>aar、lib</code>进行免混淆配置以保证<code>aar、lib</code>中的一些关键类不被混淆以免影响正常使用。（github上很多Library的README.md文件中都有对应的混淆清单提示）<br>
但是在实际的使用过程中，经常有用户会忘记在<code>App</code>中进行对应的<code>aar、lib</code>的免混淆配置，导致其功能不能正常使用（打包后关键类被混淆），这样的的操作是很不友好的。</p>
</blockquote>
<p><strong>AndroidStudio</strong>在3.x之后，其实已经为我们提供了新的解决办法，在新建<code>Module</code>后，我们会发现<code>Module</code>下有了<code>proguard-rules.pro</code>、<code>consumer-rules.pro</code>两个文件，而在<code>Module/build.gradle</code>配置文件的<code>defaultConfig</code>中，我们会发现有个<code>consumerProguardFiles</code>配置，它其实就是为了解决<code>aar、lib</code>混淆配置后<code>App</code>没有进行对应的配置导致<code>aar、lib</code>的配置未生效的问题。</p>
<p><strong>正确的解决方案（只需在aar、lib中进行对应的混淆配置，即便引用的App在混淆时不针对aar、lib进行对应的配置，打包后也不会影响aar、lib的正确混淆）：</strong><br>
在<code>Module/build.gradle</code>中配置（Android 3.x后会默认生成该配置）：</p>
<pre><code class="language-java">android {
    defaultConfig {
        consumerProguardFiles 'consumer-rules.pro'
    }
}
</code></pre>
<p>然后在在<code>Module/consumer-rules.pro</code>文件中进行具体的混淆配置。</p>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="http://blog.csdn.net/hudan2714/article/details/53191782">整理Android最全的混淆规则大全（最新的开源框架混淆）</a><br>
<a href="http://blog.csdn.net/qq_15807167/article/details/52683375">Android混淆</a><br>
<a href="https://blog.csdn.net/lhd201006/article/details/72913071">Android Studio的Proguard（代码混淆）</a><br>
<a href="https://www.v2ex.com/t/646787">Android 配置中的 consumerProguardFiles</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（四）集合框架]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-si-ji-he-kuang-jia/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-si-ji-he-kuang-jia/">
        </link>
        <updated>2020-06-19T06:24:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-概述">一、概述</h2>
<p><strong>Kotlin中集合框架相对于Java：</strong></p>
<ol>
<li>增加了“不可变”集合框架的接口；</li>
<li>没有另起炉灶，复用Java API的所有实现类型；</li>
<li>提供了丰富易用的方法，例如<code>forEach/map/flatMap</code>；</li>
<li>运算符级别的支持，简化了集合框架的访问。</li>
</ol>
<hr>
<h2 id="二-集合框架的接口类型对比">二、集合框架的接口类型对比</h2>
<table>
    <tr>
        <th></th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>不可变List</th>
        <th>List&lt;T&gt;</th>
        <th rowspan="2">List&lt;T&gt;</th>
    </tr>
    <tr>
        <th>可变List</th>
        <th>MutableList&lt;T&gt;</th>
    </tr>
    <tr>
        <th>不可变Map</th>
        <th>Map&lt;K,V&gt;</th>
        <th rowspan="2">Map&lt;K,V&gt;</th>
    </tr>
    <tr>
        <th>可变Map</th>
        <th>MutableMap&lt;K,V&gt;</th>
    </tr>
    <tr>
        <th>不可变Set</th>
        <th>Set&lt;T&gt;</th>
        <th rowspan="2">Set&lt;T&gt;</th>
    </tr>
    <tr>
        <th>可变Set</th>
        <th>MutableSet&lt;T&gt;</th>
    </tr>
</table>
<blockquote>
<p>注：Mutable标识可变的。</p>
</blockquote>
<hr>
<h2 id="三-集合框架的创建">三、集合框架的创建</h2>
<p><strong>1.List的创建</strong></p>
<ul>
<li>Java中创建List<pre><code class="language-java">  List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));
</code></pre>
</li>
<li>Kotlin中创建List<pre><code class="language-kotlin">  // 不可变List：不能添加或者删除元素
  val intList: List&lt;Int&gt; = listOf(1, 2, 3)

  // 可变List：可以添加或者删除元素
  val intList2: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)
</code></pre>
</li>
</ul>
<p><strong>2.Map的创建</strong></p>
<ul>
<li>Java中创建Map<pre><code class="language-java">   Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;zhangsan&quot;, 20)；
</code></pre>
</li>
<li>Kotlin中创建Map<pre><code class="language-kotlin">   // 不可变
    // &quot;name&quot; to &quot;zhangsan&quot;，这里可以理解为K-V(Key to Value)即可
    // Any等价于Java中的Object
    val map: Map&lt;String, Any&gt; = mapOf(&quot;name&quot; to &quot;zhangsan&quot;, &quot;age&quot; to 22)

    // 可变
    val map2: MutableMap&lt;String, Any&gt; = mutableMapOf(&quot;name&quot; to &quot;zhangsan&quot;, &quot;age&quot; to 22)
</code></pre>
</li>
</ul>
<hr>
<h2 id="四-集合实现类服用与类型别名kotlin特性">四、集合实现类服用与类型别名(Kotlin特性)</h2>
<p>以下是集合对应的类型别名：</p>
<pre><code class="language-java">    typealias ArrayList&lt;E&gt; = java.util.ArrayList&lt;E&gt;
    typealias LinkedHashMap&lt;K, V&gt; = java.util.LinedHashMap&lt;K, V&gt;
    typealias HashMap&lt;K, V&gt; = java.util.HashMap&lt;K, V&gt;
    typealias LinedHashSet&lt;E&gt; = java.util.LinedHashSet&lt;E&gt;
    typealias HashSet&lt;E&gt; = java.util.HashSet&lt;E&gt;
</code></pre>
<hr>
<h2 id="五-集合框架的修改">五、集合框架的修改</h2>
<ol>
<li><strong>添加元素</strong>
<ul>
<li>java<pre><code class="language-java">   for(int i = 0; i&lt; 10; i++){
           stringList.add(&quot;num:&quot; + i);
   }
</code></pre>
</li>
<li>kotlin<pre><code class="language-kotlin">   for(i in 0 .. 10){
       stringList += &quot;num:$i&quot;
   }
</code></pre>
</li>
</ul>
</li>
<li><strong>移除元素</strong>
<ul>
<li>java<pre><code class="language-java">   for(int i = 0; i&lt; 10; i++){
           stringList.remove(&quot;num:&quot; + i);
   }
</code></pre>
</li>
<li>kotlin<pre><code class="language-kotlin">   for(i in 0 .. 10){
       stringList -= &quot;num:$i&quot;
   }
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="六-集合框架的读写">六、集合框架的读写</h2>
<ul>
<li>java</li>
</ul>
<pre><code class="language-java">    // List的读写
    stringList.set(3, &quot;HelloWorld&quot;);
    String valueAt3 = stringList.get(3);

    // Map的读写
    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;Hello&quot;, 10);
    System.out.println(map.get(&quot;Hello&quot;));
</code></pre>
<ul>
<li>kotlin</li>
</ul>
<pre><code class="language-kotlin">    // List的读写
    stringList[3] = &quot;HelloWorld&quot;
    val valueAt3 = stringList[3]

    // Map的读写
    val map = HashMap&lt;String, Int&gt;()
    map[&quot;Hello&quot;] = 10
    println(map[&quot;Hello&quot;])

    // []内的值实际上就是key
</code></pre>
<hr>
<h2 id="七-pair">七、Pair</h2>
<p>Pair表示两个值的通用对（键值对），这个是Kotlin独有的。</p>
<pre><code class="language-java">    val pair = &quot;Hello&quot; to &quot;Kotlin&quot;
    val pair2 = Pair(&quot;Hello&quot;, &quot;Kotlin&quot;)
    val first = pair.first
    val second = pair.second

    // 解构表达式，相当于把pair拆分给x,y
    val (x, y) = pair
</code></pre>
<hr>
<h2 id="八-triple类似pair用于三个元素的键值对维护">八、Triple（类似Pair，用于三个元素的键值对维护）</h2>
<pre><code class="language-java">    val triple = Triple(&quot;x&quot;, 2, 3.0)
    val first = triple.first
    val second = triple.second
    val third = triple.third
    val (x, y, z) = triple
</code></pre>
<p>--</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Gradle之多类型、类型包名后缀、源集（对应文件资源）配置]]></title>
        <id>https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/</id>
        <link href="https://iflytek-duan.github.io/post/android-gradle-zhi-duo-lei-xing-pei-zhi/">
        </link>
        <updated>2020-06-10T01:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>一般情况下，我们的开发环境分为<code>debug</code>与<code>release</code>两个环境，这个一般在新建Android项目时，Gradle文件中已完成了默认的配置，代码如下（<code>debug</code>默认存在）：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
}
</code></pre>
<p>那么，如果我们在有的项目中需要配置其它环境（如alpha、beta等），这个时候就需要额外的配置了。</p>
<hr>
<h2 id="buildtypes配置构建类型">buildTypes（配置构建类型）</h2>
<p><code>buildTypes</code>位于<code>app-build.gradle</code>文件的<code>android{}</code>代码块中，它是用来创建和配置app的构建类型的，新建一个项目在模块的<code>build.gradle</code>文件中会默认生成<code>debug</code>与<code>release</code>两个环境版本。</p>
<hr>
<h2 id="多类型配置与其作用">多类型配置与其作用</h2>
<p>当我们app需要在不同的环境下生成对应的版本时，这个时候就需要在<code>buildTypes</code>内进行对应版本类型的配置工作（如：网络baseUrl的配置），示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    release {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-release.**/&quot;'
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }

    alpha {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-alpha.**/&quot;'
    }

    beta {
        minifyEnabled false
        buildConfigField 'String', 'BASE_URL', '&quot;http://xxxx-beta.**/&quot;'
    }
}
</code></pre>
<p>通过如上配置，我们可以实现针对不同的环境创建对应的版本类型。</p>
<blockquote>
<p>通过Gradle-&gt;app-&gt;build-&gt;assemble可以一键进行所有类型版本的构建，生成对应的apk文件。</p>
</blockquote>
<hr>
<h2 id="applicationidsuffix">applicationIdSuffix</h2>
<p>该字段表示，在不改变当前程序默认ID（包名）的情况下，为其添加后缀。如：当前包名是<code>com.zihao.app</code>，如果你想区分测试包与线上包的情况，这个时候在<code>buildTypes-&gt;debug</code>中将<code>applicationIdSuffix</code>设置为<code>applicationIdSuffix &quot;.debug&quot;</code>，那么对应的包名就变成了<code>com.zihao.app.debug</code>，示例代码如下：</p>
<pre><code class="language-java">buildTypes {
    ...
    debug {
        applicationIdSuffix &quot;.debug&quot;
    }
}
</code></pre>
<hr>
<h2 id="源集source-sets构建">源集（Source Sets）构建</h2>
<p>Android Studio会为每个模块将源代码和资源文件组成一个逻辑上的源集。每个模块的<code>main/</code>源集包括所有构建变种都是用的源码和资源。其它源集的目录是可选的，Android Studio不会自动为你创建他们，当你构建新的变种的时候。但是，构建具体的app版本的时候，创建于<code>main/</code>类似的源集，可以帮助组织Gradle应该使用的文件和资源（有助于让Gradle只应在构建特定应用版本时使用的文件和资源井然有序）。</p>
<blockquote>
<p>通常源代码是放在'src/main'文件目录下的，但是你可以根据不同的构建类型（比如debug、release、alpha等）区分不同的源文件，这样对应建立的文件夹就是一个不同的构建源。打个比方，<code>debug</code>的构建源为<code>src/debug</code>，<code>release</code>的构建源为<code>src/release</code>，而在<code>src/main</code>定义的为公共资源，最后在构建时进行合并操作。</p>
</blockquote>
<p><strong>构建源的命名规则如下</strong></p>
<ul>
<li><code>src/main/</code><br>
此源集包括所有构建变体共用的代码和资源。</li>
<li><code>src/&lt;buildTypes&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>buildType</code>使用的代码和资源。示例：<code>src/alpha</code>。</li>
<li><code>src/&lt;productFlavor&gt;/</code><br>
创建这个源集来包括仅仅为一个具体的<code>productFlavor</code>使用的代码和资源。示例：<code>src/baidu</code>。</li>
<li><code>src/&lt;productFlavorBuildType&gt;/</code><br>
创建此源集可加入特定构建变体专用的代码和资源。</li>
</ul>
<p>例如，要生成应用的“baiduDebug”版本，构建系统需要合并来自以下源集的代码、设置和资源：</p>
<ul>
<li><code>src/baiduDebug/</code>（构建变种源集）</li>
<li><code>src/debug/</code>（构建类型buildType源集）</li>
<li><code>src/baidu/</code>（productFlavor源集）</li>
<li><code>src/main/</code>（main源集）</li>
</ul>
<blockquote>
<p>注意：当你在Android Studio中创建一个新的文件或者目录时，使用File-&gt;New菜单项，你可以为一个具体的源集创建它。你可以选择的这些源集是基于你的构建配置的，并且Android Studio自动创建需要的目录，如果它们不存在的话。</p>
</blockquote>
<p><strong>源集的优先级</strong><br>
如果不同的源集包含同一个文件的不同版本，当决定哪个文件使用的时候Gradle使用下面的优先级顺序。（在左边的源集会重写右边的源集文件和设置）：</p>
<pre><code class="language-java">buildVariant &gt; buildType &gt; productFlavor &gt; main source set &gt; library dependencies
</code></pre>
<p>这可以让Gradle在构建的时候使用与具体构建变种相关的文件，当重用activity，应用逻辑，以及和其他版本通用的资源的时候。当<a href="https://developer.android.com/studio/build/manifest-merge.html">merging multiple manifests</a>的时候，Gradle使用同样的优先级顺序，因此每个构建变种可以定义不同的组件或者权限在最终的manifest文件中。<br>
学习更多关于创建自定义源集，点击<a href="https://developer.android.com/studio/build/build-variants.html">Create source sets for build variants</a>。</p>
<hr>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/89e5b0f3521e">【译】Android构建配置</a><br>
<a href="https://www.jianshu.com/p/e1efbade5d93">Android 多渠道打包配置</a><br>
<strong><a href="https://www.jianshu.com/p/a8870dccda1f">Android Studio Set of source 代码源集</a>  源集创建等操作</strong><br>
<strong><a href="https://developer.android.google.cn/studio/build/build-variants">官方文档</a></strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（三）区间 Range]]></title>
        <id>https://iflytek-duan.github.io/post/kotlinsan-qu-jian-range/</id>
        <link href="https://iflytek-duan.github.io/post/kotlinsan-qu-jian-range/">
        </link>
        <updated>2020-04-20T08:03:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>区间在Java中是没有这个概念的，它在Kotlin中是特有的。</p>
</blockquote>
<h2 id="一-区间的创建">一、区间的创建</h2>
<ul>
<li>
<p><strong>什么是区间</strong><br>
区间是数学上的一个表示范围的概念。</p>
</li>
<li>
<p><strong>区间的类型</strong></p>
<ul>
<li>
<p>闭区间<br>
闭区间是指包含起止值的区间。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ≤ x ≤ b 的实数 x 的集合,<br>
表示为 [ a,b ],叫做闭区间</em></p>
</li>
<li>
<p>开区间<br>
开区间是指不包含起止值的区间。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ＜ x ＜b 的实数 x 的集合,<br>
表示为 ( a,b ),叫做开区间</em></p>
</li>
<li>
<p>半开区间<br>
半开区间是指包含起始值或终止值得区间（也叫前半开区间、后半开区）。</p>
<p><em>例：设 a,b 是两个实数,且 a ≤ b，满足 a ≤ x ＜b,a ＜x ≤ b 的实数 x 的集合,<br>
分别表示为 [ a,b ),( a,b ],叫做半开区间</em></p>
</li>
<li>
<p>倒序区间<br>
区间的值由大到小排列。</p>
</li>
</ul>
</li>
<li>
<p><strong>区间如何创建</strong></p>
<ul>
<li>创建闭区间<pre><code class="language-kotlin">val intRange = 1..10 // [1,10]
val charRange = 'a'..'z' // [a,z]
val longRange = 1L..100L // [1L,100L]
</code></pre>
</li>
<li>创建开区间（半开区间）<pre><code class="language-kotlin">// 前闭后开区间，不包含结束值
val intRangeExclusive = 1 until 10 // [1,10)
val charRangeExclusive = 'a' until 'z' // [a,z)
val longRangeExclusive = 1L until 100L // [1L,100L)
</code></pre>
</li>
<li>创建倒序区间<pre><code class="language-kotlin">// 区间值由大到小
val intRangeReverse = 10 downTo 1 // [10,9...,1]
val charRangeReverse = 'z' downTo 'a' // [z,a]
val longRangeReverse = 100L downTo 1L // [100L,1L]
</code></pre>
</li>
<li>区间值的打印<br>
通过<code>println(range.joinToString())</code>方法打印即可。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二-区间的步长">二、区间的步长</h2>
<blockquote>
<p>在创建区间时，有时候我们希望区间值之间以固定的间隔进行跳跃，例如原先排列为1，2，3，4，...，10的区间想变成1,3,5,7,...,9的区间，这个时候我们可以通过设置区间的步长（即两两之间的间隔）来达到预期。</p>
</blockquote>
<pre><code class="language-kotlin">// 区间步长的使用
val intRangeWithStep = 1...10 step 2 // [1,3,5,...,9]
val charRangeWithStep = 'a'...'z' step 2 // [a,c,e,...,y]
val longRangeWithStep = 1L...100L step 2 // [1L,3L,...,99L]
</code></pre>
<hr>
<h2 id="三-区间的迭代">三、区间的迭代</h2>
<blockquote>
<p>区间的迭代方式类似于数组的迭代方式。</p>
</blockquote>
<pre><code class="language-kotlin">for(element in intRange){
    println(element)
}

intRange.foreach{
    println(it)
}
</code></pre>
<hr>
<h2 id="四-区间的包含关系">四、区间的包含关系</h2>
<pre><code class="language-kotlin">if(3 in intRage){
    println(&quot;3 in range 'intRange'&quot;)
}

if(12 !in intRange){
    println(&quot;12 not in range 'intRange'&quot;)
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】（二）数组Array]]></title>
        <id>https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/</id>
        <link href="https://iflytek-duan.github.io/post/kotlin-er-shu-zu-array/">
        </link>
        <updated>2020-04-20T03:10:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-kotlin-java中的数组对比">一、Kotlin、Java中的数组对比</h2>
<table>
    <tr>
        <th>数组分类</th>
        <th>Kotlin</th>
        <th>Java</th>
    </tr>
    <tr>
        <th>整型</th>
        <th>IntArray</th>
        <th>int[]</th>
    </tr>
    <tr>
        <th>整型装箱</th>
        <th>Array&lt;Int&gt;</th>
        <th>Integer[]</th>
    </tr>
    <tr>
        <th>字符</th>
        <th>CharArray</th>
        <th>char[]</th>
    </tr>
    <tr>
        <th>字符装箱</th>
        <th>Array&lt;Char&gt;</th>
        <th>Character[]</th>
    </tr>
    <tr>
        <th>字符串</th>
        <th>Array<String></th>
        <th>String[]</th>
    </tr>
    <tr>
        <th>浮点型</th>
        <th>FloatArray</th>
        <th>float[]</th>
    </tr>
    <tr>
        <th>浮点型装箱</th>
        <th>Array&lt;Float&gt;</th>
        <th>Float[]</th>
    </tr>
    <tr>
        <th>双精度</th>
        <th>DoubleArray</th>
        <th>double[]</th>
    </tr>
    <tr>
        <th>双精度装箱</th>
        <th>Array&lt;Double&gt;</th>
        <th>Double[]</th>
    </tr>
</table>
<hr>
<h2 id="二-数组的创建">二、数组的创建</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] c = new int[]{1,2,3,4,5};
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val k0 = intArrayOf(1,2,3,4,5) // 变长参数
val k1 = IntArray(5){ it + 1 }// kotlin中新建一个对象不需要new关键字，参数一：数 组长度；参数二：lamda表达式，it的值为数组下标。

println(k0.contentToString())
println(k1.contentToString())
</code></pre>
</li>
</ul>
<hr>
<h2 id="三-数组的长度">三、数组的长度</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">int[] array = new int[5];
System.out.println(array.length);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val array = IntArray(5)
println(array.size)
</code></pre>
</li>
</ul>
<hr>
<h2 id="四-数组的读写">四、数组的读写</h2>
<ul>
<li>
<p><strong>Java</strong></p>
<pre><code class="language-java">String[] str = new String[]{&quot;Hello&quot;,&quot;World&quot;};
str[1] = &quot;Java&quot;;
System.out.println(str[0] + &quot;, &quot; + str[1]);
</code></pre>
</li>
<li>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">val str = arrayOf(&quot;Hello&quot;,&quot;World&quot;)
str[1] = &quot;Kotlin&quot;
println(&quot;${str[0]}, ${str[1]}&quot;)// 使用字符串模板打印
</code></pre>
</li>
</ul>
<hr>
<h2 id="五-数组的遍历">五、数组的遍历</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">float[] floats = new float[]{1,3,5,7};
for(float element : floats){
    System.out.println(element);
}

for(int i=0;i&lt;floats.length;i++){
    System.out.println(floats[i]);
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val floatArray = floatArrayOf(1f,3f,5f,7f)
for(element in floatArray){
    println(element)
}

// 或者使用以下方式遍历
floatArray.foreach{ element -&gt;
  println(element)
}

// 或者下面的方式（对标java中的 for(int i=0;i&lt;floats.length;i++)遍历方式）
for(i in floats.indices){
    println(floats[i])
}
</code></pre>
</li>
</ul>
<hr>
<h2 id="六-判断数组中是否包含某个元素数组的包含关系">六、判断数组中是否包含某个元素（数组的包含关系）</h2>
<ul>
<li><strong>Java</strong><pre><code class="language-java">int[] intArray = new int[]{1,2,3,4,5};
for(int i : intArray){
    if(i == 4){
        System.out.println(&quot;4 exists in variable 'intArray'&quot;);
    }
}
</code></pre>
</li>
<li><strong>Kotlin</strong><pre><code class="language-kotlin">val intArray = IntArray(5){ it +1 }
if(4 in intArray){
    println(&quot;4 exists in variable 'intArray'&quot;)
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
</feed>